//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer NamedElementSerializer for DomainClass NamedElement.
	/// </summary>
	public partial class NamedElementSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// NamedElementSerializer Constructor
		/// </summary>
		public NamedElementSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// Cannot be serialized.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// NamedElement is abstract and cannot be instantiated, so this method throws NotSupportedException.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the NamedElement element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NamedElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NamedElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			NamedElement instanceOfNamedElement = element as NamedElement;
			global::System.Diagnostics.Debug.Assert(instanceOfNamedElement != null, "Expecting an instance of NamedElement");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				string attribName = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "name");
				if (attribName != null)
				{
					global::System.String valueOfName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribName, out valueOfName))
					{
						instanceOfNamedElement.Name = valueOfName;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "name", typeof(global::System.String), attribName);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of NamedElement based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized NamedElement, a new NamedElement instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created NamedElement instance, or null if the reader is not pointing to a serialized NamedElement instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "NamedElement".
				if (this.derivedClasses == null)
					this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class instance.
					NamedElementSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NamedElementSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of NamedElement based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of NamedElement.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new NamedElement instance should be created.</param>	
		/// <returns>Created NamedElement instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Abstract class, cannot be serialized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from NamedElement, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from NamedElement.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NamedElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including NamedElement itself) instance of NamedElement based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "NamedElement".
				if (this.derivedClassMonikers == null)
					this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class moniker instance.
					NamedElementSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NamedElementSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of NamedElement based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				RapidEntitySerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, NamedElement.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from NamedElement, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from NamedElement.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NamedElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized NamedElement instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NamedElement instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the NamedElement instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the NamedElement instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of NamedElement cannot be monikerized.
			RapidEntitySerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "NamedElement");
		}
		
		/// <summary>
		/// Public Write() method that serializes one NamedElement instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NamedElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NamedElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			NamedElement instanceOfNamedElement = element as NamedElement;
			global::System.Diagnostics.Debug.Assert(instanceOfNamedElement != null, "Expecting an instance of NamedElement");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfNamedElement.Name;
				if (!serializationContext.Result.Failed)
				{
					RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "name", propValue);
				}
			}
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given NamedElement instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NamedElement instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the NamedElement instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NamedElement instance = element as NamedElement;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NamedElement!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NamedElement instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NamedElement instance = element as NamedElement;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NamedElement!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer ModelRootSerializer for DomainClass ModelRoot.
	/// </summary>
	public partial class ModelRootSerializer : NamedElementSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelRootSerializer Constructor
		/// </summary>
		public ModelRootSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ModelRoot.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelRoot"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ModelRoot.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelRootMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ModelRoot in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ModelRoot instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ModelRoot element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelRoot instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelRoot instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
			ModelRoot instanceOfModelRoot = element as ModelRoot;
			global::System.Diagnostics.Debug.Assert(instanceOfModelRoot != null, "Expecting an instance of ModelRoot!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfModelRoot, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory ModelRoot instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, ModelRoot element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
					case "comments":	// Relationship "ModelRootHasComments"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <comments>
							ReadModelRootHasCommentsInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </comments>
						}
						break;
					case "types":	// Relationship "ModelRootHasTypes"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <types>
							ReadModelRootHasTypesInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </types>
						}
						break;
					default:
						return;  // Don't know this element.
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship ModelRootHasComments.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelRoot instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadModelRootHasCommentsInstances(DslModeling::SerializationContext serializationContext, ModelRoot element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newCommentOfModelRootHasCommentsSerializer = serializationContext.Directory.GetSerializer(Comment.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newCommentOfModelRootHasCommentsSerializer != null, "Cannot find serializer for Comment!");
				Comment newCommentOfModelRootHasComments = newCommentOfModelRootHasCommentsSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as Comment;
				if (newCommentOfModelRootHasComments != null)
				{
					element.Comments.Add(newCommentOfModelRootHasComments);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newCommentOfModelRootHasComments.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newCommentOfModelRootHasComments.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newCommentOfModelRootHasComments, reader);
				}
				else
				{
					global::System.Type typeofModelRootHasComments = typeof(ModelRootHasComments);
					DslModeling::DomainRelationshipXmlSerializer newModelRootHasCommentsSerializer = serializationContext.Directory.GetSerializer(ModelRootHasComments.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newModelRootHasCommentsSerializer != null, "Cannot find serializer for ModelRootHasComments!");
					ModelRootHasComments newModelRootHasComments = newModelRootHasCommentsSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ModelRootHasComments;
					if (newModelRootHasComments != null)
					{
						if (newModelRootHasComments.GetType() == typeofModelRootHasComments)
						{	// The relationship should be serialized in short-form.
							RapidEntitySerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(ModelRootHasComments));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newModelRootHasComments, ModelRootHasComments.ModelRootDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelRootHasComments.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelRootHasComments.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newModelRootHasComments, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship ModelRootHasTypes.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelRoot instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadModelRootHasTypesInstances(DslModeling::SerializationContext serializationContext, ModelRoot element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newModelTypeOfModelRootHasTypesSerializer = serializationContext.Directory.GetSerializer(ModelType.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newModelTypeOfModelRootHasTypesSerializer != null, "Cannot find serializer for ModelType!");
				ModelType newModelTypeOfModelRootHasTypes = newModelTypeOfModelRootHasTypesSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as ModelType;
				if (newModelTypeOfModelRootHasTypes != null)
				{
					element.Types.Add(newModelTypeOfModelRootHasTypes);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelTypeOfModelRootHasTypes.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelTypeOfModelRootHasTypes.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newModelTypeOfModelRootHasTypes, reader);
				}
				else
				{
					global::System.Type typeofModelRootHasTypes = typeof(ModelRootHasTypes);
					DslModeling::DomainRelationshipXmlSerializer newModelRootHasTypesSerializer = serializationContext.Directory.GetSerializer(ModelRootHasTypes.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newModelRootHasTypesSerializer != null, "Cannot find serializer for ModelRootHasTypes!");
					ModelRootHasTypes newModelRootHasTypes = newModelRootHasTypesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ModelRootHasTypes;
					if (newModelRootHasTypes != null)
					{
						if (newModelRootHasTypes.GetType() == typeofModelRootHasTypes)
						{	// The relationship should be serialized in short-form.
							RapidEntitySerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(ModelRootHasTypes));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newModelRootHasTypes, ModelRootHasTypes.ModelRootDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelRootHasTypes.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelRootHasTypes.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newModelRootHasTypes, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ModelRoot based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ModelRoot, a new ModelRoot instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a serialized ModelRoot instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelRoot" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ModelRoot".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ModelRootSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelRootSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ModelRoot based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ModelRoot.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ModelRoot instance should be created.</param>	
		/// <returns>Created ModelRoot instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new ModelRoot(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelRoot, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelRoot.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelRoot.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ModelRoot itself) instance of ModelRoot based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelRoot" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ModelRoot".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ModelRootSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelRootSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ModelRoot based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				RapidEntitySerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, ModelRoot.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelRoot, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelRoot.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelRoot.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ModelRoot instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelRoot instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ModelRoot instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelRoot instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ModelRoot instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelRoot instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelRoot instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
			ModelRoot instance = element as ModelRoot;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelRoot!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
		
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelRoot instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, ModelRoot element, global::System.Xml.XmlWriter writer)
		{
			// ModelRootHasComments
			global::System.Collections.ObjectModel.ReadOnlyCollection<ModelRootHasComments> allModelRootHasCommentsInstances = ModelRootHasComments.GetLinksToComments(element);
			if (!serializationContext.Result.Failed && allModelRootHasCommentsInstances.Count > 0)
			{
				writer.WriteStartElement("comments");
				global::System.Type typeofModelRootHasComments = typeof(ModelRootHasComments);
				foreach (ModelRootHasComments eachModelRootHasCommentsInstance in allModelRootHasCommentsInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachModelRootHasCommentsInstance.GetType() != typeofModelRootHasComments)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachModelRootHasCommentsInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachModelRootHasCommentsInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachModelRootHasCommentsInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachModelRootHasCommentsInstance.Comment;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
			// ModelRootHasTypes
			global::System.Collections.ObjectModel.ReadOnlyCollection<ModelRootHasTypes> allModelRootHasTypesInstances = ModelRootHasTypes.GetLinksToTypes(element);
			if (!serializationContext.Result.Failed && allModelRootHasTypesInstances.Count > 0)
			{
				writer.WriteStartElement("types");
				global::System.Type typeofModelRootHasTypes = typeof(ModelRootHasTypes);
				foreach (ModelRootHasTypes eachModelRootHasTypesInstance in allModelRootHasTypesInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachModelRootHasTypesInstance.GetType() != typeofModelRootHasTypes)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachModelRootHasTypesInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachModelRootHasTypesInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachModelRootHasTypesInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachModelRootHasTypesInstance.Type;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelRoot instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelRoot instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelRoot instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelRoot instance = element as ModelRoot;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelRoot!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelRoot instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelRoot instance = element as ModelRoot;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelRoot!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer ModelClassSerializer for DomainClass ModelClass.
	/// </summary>
	public partial class ModelClassSerializer : ModelTypeSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelClassSerializer Constructor
		/// </summary>
		public ModelClassSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ModelClass.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelClass"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ModelClass.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelClassMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ModelClass in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ModelClass instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ModelClass element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			ModelClass instanceOfModelClass = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instanceOfModelClass != null, "Expecting an instance of ModelClass");
	
			// Kind
			if (!serializationContext.Result.Failed)
			{
				string attribKind = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "kind");
				if (attribKind != null)
				{
					global::System.String valueOfKind;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribKind, out valueOfKind))
					{
						instanceOfModelClass.Kind = valueOfKind;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "kind", typeof(global::System.String), attribKind);
					}
				}
			}
			// IsAbstract
			if (!serializationContext.Result.Failed)
			{
				string attribIsAbstract = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isAbstract");
				if (attribIsAbstract != null)
				{
					InheritanceModifier valueOfIsAbstract;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritanceModifier>(serializationContext, attribIsAbstract, out valueOfIsAbstract))
					{
						instanceOfModelClass.IsAbstract = valueOfIsAbstract;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isAbstract", typeof(InheritanceModifier), attribIsAbstract);
					}
				}
			}
			// TableName
			if (!serializationContext.Result.Failed)
			{
				string attribTableName = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "tableName");
				if (attribTableName != null)
				{
					global::System.String valueOfTableName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTableName, out valueOfTableName))
					{
						instanceOfModelClass.TableName = valueOfTableName;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "tableName", typeof(global::System.String), attribTableName);
					}
				}
			}
			// ParentName
			if (!serializationContext.Result.Failed)
			{
				string attribParentName = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "parentName");
				if (attribParentName != null)
				{
					global::System.String valueOfParentName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribParentName, out valueOfParentName))
					{
						instanceOfModelClass.ParentName = valueOfParentName;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "parentName", typeof(global::System.String), attribParentName);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
			ModelClass instanceOfModelClass = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instanceOfModelClass != null, "Expecting an instance of ModelClass!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfModelClass, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
					case "fields":	// Relationship "ClassHasFields"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <fields>
							ReadClassHasFieldsInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </fields>
						}
						break;
					case "subclasses":	// Relationship "Generalization"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <subclasses>
							ReadGeneralizationInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </subclasses>
						}
						break;
					case "oneToOneTargets":	// Relationship "OneToOne"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <oneToOneTargets>
							ReadOneToOneInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </oneToOneTargets>
						}
						break;
					case "oneToManyTargets":	// Relationship "OneToMany"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <oneToManyTargets>
							ReadOneToManyInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </oneToManyTargets>
						}
						break;
					case "manyTargetModel":	// Relationship "ManyToMany"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <manyTargetModel>
							ReadManyToManyInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </manyTargetModel>
						}
						break;
					case "persistentKeys":	// Relationship "ClassHasPersistentKeys"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <persistentKeys>
							ReadClassHasPersistentKeysInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </persistentKeys>
						}
						break;
					default:
						return;  // Don't know this element.
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship ClassHasFields.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadClassHasFieldsInstances(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newFieldOfClassHasFieldsSerializer = serializationContext.Directory.GetSerializer(Field.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newFieldOfClassHasFieldsSerializer != null, "Cannot find serializer for Field!");
				Field newFieldOfClassHasFields = newFieldOfClassHasFieldsSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as Field;
				if (newFieldOfClassHasFields != null)
				{
					element.Fields.Add(newFieldOfClassHasFields);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newFieldOfClassHasFields.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newFieldOfClassHasFields.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newFieldOfClassHasFields, reader);
				}
				else
				{
					global::System.Type typeofClassHasFields = typeof(ClassHasFields);
					DslModeling::DomainRelationshipXmlSerializer newClassHasFieldsSerializer = serializationContext.Directory.GetSerializer(ClassHasFields.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newClassHasFieldsSerializer != null, "Cannot find serializer for ClassHasFields!");
					ClassHasFields newClassHasFields = newClassHasFieldsSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ClassHasFields;
					if (newClassHasFields != null)
					{
						if (newClassHasFields.GetType() == typeofClassHasFields)
						{	// The relationship should be serialized in short-form.
							RapidEntitySerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(ClassHasFields));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newClassHasFields, ClassHasFields.ModelClassDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newClassHasFields.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newClassHasFields.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newClassHasFields, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship Generalization.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadGeneralizationInstances(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newGeneralizationSerializer = serializationContext.Directory.GetSerializer(Generalization.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newGeneralizationSerializer != null, "Cannot find serializer for Generalization!");
				Generalization newGeneralization = newGeneralizationSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as Generalization;
				if (newGeneralization != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newGeneralization, Generalization.SuperclassDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newGeneralization.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newGeneralization.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newGeneralization, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newModelClassMonikerOfGeneralizationSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newModelClassMonikerOfGeneralizationSerializer != null, "Cannot find serializer for ModelClass!");
					DslModeling::Moniker newModelClassMonikerOfGeneralization = newModelClassMonikerOfGeneralizationSerializer.TryCreateMonikerInstance(serializationContext, reader, element, Generalization.DomainClassId, element.Partition);
					if (newModelClassMonikerOfGeneralization != null)
					{
						RapidEntitySerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(Generalization));
						new Generalization(element.Partition, new DslModeling::RoleAssignment(Generalization.SuperclassDomainRoleId, element), new DslModeling::RoleAssignment(Generalization.SubclassDomainRoleId, newModelClassMonikerOfGeneralization));
						DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship OneToOne.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadOneToOneInstances(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newOneToOneSerializer = serializationContext.Directory.GetSerializer(OneToOne.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newOneToOneSerializer != null, "Cannot find serializer for OneToOne!");
				OneToOne newOneToOne = newOneToOneSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as OneToOne;
				if (newOneToOne != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newOneToOne, OneToOne.BidirectionalSourceDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newOneToOne.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newOneToOne.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newOneToOne, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newModelClassMonikerOfOneToOneSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newModelClassMonikerOfOneToOneSerializer != null, "Cannot find serializer for ModelClass!");
					DslModeling::Moniker newModelClassMonikerOfOneToOne = newModelClassMonikerOfOneToOneSerializer.TryCreateMonikerInstance(serializationContext, reader, element, OneToOne.DomainClassId, element.Partition);
					if (newModelClassMonikerOfOneToOne != null)
					{
						RapidEntitySerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(OneToOne));
						new OneToOne(element.Partition, new DslModeling::RoleAssignment(OneToOne.BidirectionalSourceDomainRoleId, element), new DslModeling::RoleAssignment(OneToOne.BidirectionalTargetDomainRoleId, newModelClassMonikerOfOneToOne));
						DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship OneToMany.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadOneToManyInstances(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newOneToManySerializer = serializationContext.Directory.GetSerializer(OneToMany.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newOneToManySerializer != null, "Cannot find serializer for OneToMany!");
				OneToMany newOneToMany = newOneToManySerializer.TryCreateInstance (serializationContext, reader, element.Partition) as OneToMany;
				if (newOneToMany != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newOneToMany, OneToMany.AggregationSourceDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newOneToMany.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newOneToMany.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newOneToMany, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newModelClassMonikerOfOneToManySerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newModelClassMonikerOfOneToManySerializer != null, "Cannot find serializer for ModelClass!");
					DslModeling::Moniker newModelClassMonikerOfOneToMany = newModelClassMonikerOfOneToManySerializer.TryCreateMonikerInstance(serializationContext, reader, element, OneToMany.DomainClassId, element.Partition);
					if (newModelClassMonikerOfOneToMany != null)
					{
						RapidEntitySerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(OneToMany));
						new OneToMany(element.Partition, new DslModeling::RoleAssignment(OneToMany.AggregationSourceDomainRoleId, element), new DslModeling::RoleAssignment(OneToMany.AggregationTargetDomainRoleId, newModelClassMonikerOfOneToMany));
						DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship ManyToMany.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadManyToManyInstances(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newManyToManySerializer = serializationContext.Directory.GetSerializer(ManyToMany.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newManyToManySerializer != null, "Cannot find serializer for ManyToMany!");
				ManyToMany newManyToMany = newManyToManySerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ManyToMany;
				if (newManyToMany != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newManyToMany, ManyToMany.SourceModelClassDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newManyToMany.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newManyToMany.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newManyToMany, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newModelClassMonikerOfManyToManySerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newModelClassMonikerOfManyToManySerializer != null, "Cannot find serializer for ModelClass!");
					DslModeling::Moniker newModelClassMonikerOfManyToMany = newModelClassMonikerOfManyToManySerializer.TryCreateMonikerInstance(serializationContext, reader, element, ManyToMany.DomainClassId, element.Partition);
					if (newModelClassMonikerOfManyToMany != null)
					{
						RapidEntitySerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(ManyToMany));
						new ManyToMany(element.Partition, new DslModeling::RoleAssignment(ManyToMany.SourceModelClassDomainRoleId, element), new DslModeling::RoleAssignment(ManyToMany.TargetModelClassDomainRoleId, newModelClassMonikerOfManyToMany));
						DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship ClassHasPersistentKeys.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadClassHasPersistentKeysInstances(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newPersistentKeyOfClassHasPersistentKeysSerializer = serializationContext.Directory.GetSerializer(PersistentKey.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newPersistentKeyOfClassHasPersistentKeysSerializer != null, "Cannot find serializer for PersistentKey!");
				PersistentKey newPersistentKeyOfClassHasPersistentKeys = newPersistentKeyOfClassHasPersistentKeysSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as PersistentKey;
				if (newPersistentKeyOfClassHasPersistentKeys != null)
				{
					element.PersistentKeys.Add(newPersistentKeyOfClassHasPersistentKeys);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newPersistentKeyOfClassHasPersistentKeys.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newPersistentKeyOfClassHasPersistentKeys.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newPersistentKeyOfClassHasPersistentKeys, reader);
				}
				else
				{
					global::System.Type typeofClassHasPersistentKeys = typeof(ClassHasPersistentKeys);
					DslModeling::DomainRelationshipXmlSerializer newClassHasPersistentKeysSerializer = serializationContext.Directory.GetSerializer(ClassHasPersistentKeys.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newClassHasPersistentKeysSerializer != null, "Cannot find serializer for ClassHasPersistentKeys!");
					ClassHasPersistentKeys newClassHasPersistentKeys = newClassHasPersistentKeysSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ClassHasPersistentKeys;
					if (newClassHasPersistentKeys != null)
					{
						if (newClassHasPersistentKeys.GetType() == typeofClassHasPersistentKeys)
						{	// The relationship should be serialized in short-form.
							RapidEntitySerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(ClassHasPersistentKeys));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newClassHasPersistentKeys, ClassHasPersistentKeys.ModelClassDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newClassHasPersistentKeys.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newClassHasPersistentKeys.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newClassHasPersistentKeys, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ModelClass based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ModelClass, a new ModelClass instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ModelClass instance, or null if the reader is not pointing to a serialized ModelClass instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelClass" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ModelClass".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ModelClassSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelClassSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ModelClass based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ModelClass.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ModelClass instance should be created.</param>	
		/// <returns>Created ModelClass instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new ModelClass(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelClass, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ModelClass itself) instance of ModelClass based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelClass" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ModelClass".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ModelClassSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelClassSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ModelClass based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				RapidEntitySerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, ModelClass.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelClass, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ModelClass instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelClass instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ModelClass instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelClass instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ModelClass instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			ModelClass instanceOfModelClass = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instanceOfModelClass != null, "Expecting an instance of ModelClass");
	
			// Kind
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.Kind;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
					{	// No need to write the value out if it's the same as default value.
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "kind", propValue);
					}
				}
			}
			// IsAbstract
			if (!serializationContext.Result.Failed)
			{
				InheritanceModifier propValue = instanceOfModelClass.IsAbstract;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritanceModifier>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
					{	// No need to write the value out if it's the same as default value.
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isAbstract", serializedPropValue);
					}
				}
			}
			// TableName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.TableName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "tableName", propValue);
	
				}
			}
			// ParentName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.ParentName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "parentName", propValue);
	
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
			ModelClass instance = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelClass!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
		
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlWriter writer)
		{
			// ClassHasFields
			global::System.Collections.ObjectModel.ReadOnlyCollection<ClassHasFields> allClassHasFieldsInstances = ClassHasFields.GetLinksToFields(element);
			if (!serializationContext.Result.Failed && allClassHasFieldsInstances.Count > 0)
			{
				writer.WriteStartElement("fields");
				global::System.Type typeofClassHasFields = typeof(ClassHasFields);
				foreach (ClassHasFields eachClassHasFieldsInstance in allClassHasFieldsInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachClassHasFieldsInstance.GetType() != typeofClassHasFields)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachClassHasFieldsInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachClassHasFieldsInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachClassHasFieldsInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachClassHasFieldsInstance.Attribute;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
			// Generalization
			global::System.Collections.ObjectModel.ReadOnlyCollection<Generalization> allGeneralizationInstances = Generalization.GetLinksToSubclasses(element);
			if (!serializationContext.Result.Failed && allGeneralizationInstances.Count > 0)
			{
				writer.WriteStartElement("subclasses");
				foreach (Generalization eachGeneralizationInstance in allGeneralizationInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachGeneralizationInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachGeneralizationInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachGeneralizationInstance, writer);
				}
				writer.WriteEndElement();
			}
	
			// OneToOne
			global::System.Collections.ObjectModel.ReadOnlyCollection<OneToOne> allOneToOneInstances = OneToOne.GetLinksToOneToOneTargets(element);
			if (!serializationContext.Result.Failed && allOneToOneInstances.Count > 0)
			{
				writer.WriteStartElement("oneToOneTargets");
				foreach (OneToOne eachOneToOneInstance in allOneToOneInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachOneToOneInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachOneToOneInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachOneToOneInstance, writer);
				}
				writer.WriteEndElement();
			}
	
			// OneToMany
			global::System.Collections.ObjectModel.ReadOnlyCollection<OneToMany> allOneToManyInstances = OneToMany.GetLinksToOneToManyTargets(element);
			if (!serializationContext.Result.Failed && allOneToManyInstances.Count > 0)
			{
				writer.WriteStartElement("oneToManyTargets");
				foreach (OneToMany eachOneToManyInstance in allOneToManyInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachOneToManyInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachOneToManyInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachOneToManyInstance, writer);
				}
				writer.WriteEndElement();
			}
	
			// ManyToMany
			global::System.Collections.ObjectModel.ReadOnlyCollection<ManyToMany> allManyToManyInstances = ManyToMany.GetLinksToManyTargetModel(element);
			if (!serializationContext.Result.Failed && allManyToManyInstances.Count > 0)
			{
				writer.WriteStartElement("manyTargetModel");
				foreach (ManyToMany eachManyToManyInstance in allManyToManyInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachManyToManyInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachManyToManyInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachManyToManyInstance, writer);
				}
				writer.WriteEndElement();
			}
	
			// ClassHasPersistentKeys
			global::System.Collections.ObjectModel.ReadOnlyCollection<ClassHasPersistentKeys> allClassHasPersistentKeysInstances = ClassHasPersistentKeys.GetLinksToPersistentKeys(element);
			if (!serializationContext.Result.Failed && allClassHasPersistentKeysInstances.Count > 0)
			{
				writer.WriteStartElement("persistentKeys");
				global::System.Type typeofClassHasPersistentKeys = typeof(ClassHasPersistentKeys);
				foreach (ClassHasPersistentKeys eachClassHasPersistentKeysInstance in allClassHasPersistentKeysInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachClassHasPersistentKeysInstance.GetType() != typeofClassHasPersistentKeys)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachClassHasPersistentKeysInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachClassHasPersistentKeysInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachClassHasPersistentKeysInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachClassHasPersistentKeysInstance.PersistentKey;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelClass instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelClass instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelClass instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelClass instance = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelClass!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelClass instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelClass instance = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelClass!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer FieldSerializer for DomainClass Field.
	/// </summary>
	public partial class FieldSerializer : ModelAttributeSerializer
	{
		#region Constructor
		/// <summary>
		/// FieldSerializer Constructor
		/// </summary>
		public FieldSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Field.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"field"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of Field.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"fieldMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of Field in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Field instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Field element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Field instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of Field based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Field, a new Field instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Field instance, or null if the reader is not pointing to a serialized Field instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Field" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Field".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						FieldSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as FieldSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Field based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Field.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Field instance should be created.</param>	
		/// <returns>Created Field instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new Field(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Field, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Field.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Field.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Field itself) instance of Field based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Field" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Field".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						FieldSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as FieldSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Field based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				RapidEntitySerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, Field.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Field, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Field.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Field.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Field instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Field instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Field instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Field instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one Field instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Field instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Field instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Field instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Field instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Field instance = element as Field;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Field!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Field instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Field instance = element as Field;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Field!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer CommentSerializer for DomainClass Comment.
	/// </summary>
	public partial class CommentSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// CommentSerializer Constructor
		/// </summary>
		public CommentSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Comment.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"comment"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of Comment.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"commentMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of Comment in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Comment instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Comment element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Comment instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Comment instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			Comment instanceOfComment = element as Comment;
			global::System.Diagnostics.Debug.Assert(instanceOfComment != null, "Expecting an instance of Comment");
	
			// Text
			if (!serializationContext.Result.Failed)
			{
				string attribText = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "text");
				if (attribText != null)
				{
					global::System.String valueOfText;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribText, out valueOfText))
					{
						instanceOfComment.Text = valueOfText;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "text", typeof(global::System.String), attribText);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Comment instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
			Comment instanceOfComment = element as Comment;
			global::System.Diagnostics.Debug.Assert(instanceOfComment != null, "Expecting an instance of Comment!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfComment, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory Comment instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, Comment element, global::System.Xml.XmlReader reader)
		{
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				if (string.Compare(reader.LocalName, "subjects", global::System.StringComparison.CurrentCulture) == 0)
				{
					if (reader.IsEmptyElement)
					{	// No instance of this relationship, just skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
					else
					{
						DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <subjects>
						ReadCommentReferencesSubjectsInstances(serializationContext, element, reader);
						DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </subjects>
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship CommentReferencesSubjects.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Comment instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadCommentReferencesSubjectsInstances(DslModeling::SerializationContext serializationContext, Comment element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newModelTypeMonikerOfCommentReferencesSubjectsSerializer = serializationContext.Directory.GetSerializer(ModelType.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newModelTypeMonikerOfCommentReferencesSubjectsSerializer != null, "Cannot find serializer for ModelType!");
				DslModeling::Moniker newModelTypeMonikerOfCommentReferencesSubjects = newModelTypeMonikerOfCommentReferencesSubjectsSerializer.TryCreateMonikerInstance(serializationContext, reader, element, CommentReferencesSubjects.DomainClassId, element.Partition);
				if (newModelTypeMonikerOfCommentReferencesSubjects != null)
				{
					new CommentReferencesSubjects(element.Partition, new DslModeling::RoleAssignment(CommentReferencesSubjects.CommentDomainRoleId, element), new DslModeling::RoleAssignment(CommentReferencesSubjects.SubjectDomainRoleId, newModelTypeMonikerOfCommentReferencesSubjects));
					DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
				}
				else
				{
					global::System.Type typeofCommentReferencesSubjects = typeof(CommentReferencesSubjects);
					DslModeling::DomainRelationshipXmlSerializer newCommentReferencesSubjectsSerializer = serializationContext.Directory.GetSerializer(CommentReferencesSubjects.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newCommentReferencesSubjectsSerializer != null, "Cannot find serializer for CommentReferencesSubjects!");
					CommentReferencesSubjects newCommentReferencesSubjects = newCommentReferencesSubjectsSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as CommentReferencesSubjects;
					if (newCommentReferencesSubjects != null)
					{
						if (newCommentReferencesSubjects.GetType() == typeofCommentReferencesSubjects)
						{	// The relationship should be serialized in short-form.
							RapidEntitySerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(CommentReferencesSubjects));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newCommentReferencesSubjects, CommentReferencesSubjects.CommentDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newCommentReferencesSubjects.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newCommentReferencesSubjects.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newCommentReferencesSubjects, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of Comment based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Comment, a new Comment instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Comment instance, or null if the reader is not pointing to a serialized Comment instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Comment" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Comment".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						CommentSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Comment based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Comment.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Comment instance should be created.</param>	
		/// <returns>Created Comment instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					RapidEntitySerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new Comment(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Comment, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Comment.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Comment.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Comment itself) instance of Comment based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Comment" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Comment".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						CommentSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Comment based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				RapidEntitySerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, Comment.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Comment, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Comment.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Comment.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Comment instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Comment instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Comment instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Comment instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one Comment instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Comment instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Comment instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			Comment instanceOfComment = element as Comment;
			global::System.Diagnostics.Debug.Assert(instanceOfComment != null, "Expecting an instance of Comment");
	
			// Text
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfComment.Text;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
					{	// No need to write the value out if it's the same as default value.
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "text", propValue);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Comment instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
			Comment instance = element as Comment;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Comment!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
		
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Comment instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, Comment element, global::System.Xml.XmlWriter writer)
		{
			// CommentReferencesSubjects
			global::System.Collections.ObjectModel.ReadOnlyCollection<CommentReferencesSubjects> allCommentReferencesSubjectsInstances = CommentReferencesSubjects.GetLinksToSubjects(element);
			if (!serializationContext.Result.Failed && allCommentReferencesSubjectsInstances.Count > 0)
			{
				DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(CommentReferencesSubjects.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
				global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for CommentReferencesSubjects!");
	
				writer.WriteStartElement("subjects");
				global::System.Type typeofCommentReferencesSubjects = typeof(CommentReferencesSubjects);
				foreach (CommentReferencesSubjects eachCommentReferencesSubjectsInstance in allCommentReferencesSubjectsInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachCommentReferencesSubjectsInstance.GetType() != typeofCommentReferencesSubjects)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachCommentReferencesSubjectsInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachCommentReferencesSubjectsInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachCommentReferencesSubjectsInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachCommentReferencesSubjectsInstance.Subject;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.WriteMoniker(serializationContext, targetElement, writer, element, relSerializer);
					}
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Comment instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Comment instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Comment instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Comment instance = element as Comment;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Comment!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Comment instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer ModelTypeSerializer for DomainClass ModelType.
	/// </summary>
	public partial class ModelTypeSerializer : ClassModelElementSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelTypeSerializer Constructor
		/// </summary>
		public ModelTypeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// Cannot be serialized.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// ModelType is abstract and cannot be instantiated, so this method throws NotSupportedException.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ModelType element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelType instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			throw new global::System.NotSupportedException();
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ModelType based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ModelType, a new ModelType instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ModelType instance, or null if the reader is not pointing to a serialized ModelType instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "ModelType".
				if (this.derivedClasses == null)
					this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class instance.
					ModelTypeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelTypeSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ModelType based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ModelType.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ModelType instance should be created.</param>	
		/// <returns>Created ModelType instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Abstract class, cannot be serialized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelType, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelType.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelType.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ModelType itself) instance of ModelType based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "ModelType".
				if (this.derivedClassMonikers == null)
					this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class moniker instance.
					ModelTypeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelTypeSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ModelType based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				RapidEntitySerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, ModelType.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelType, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelType.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelType.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ModelType instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelType instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ModelType instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelType instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ModelType cannot be monikerized.
			RapidEntitySerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ModelType");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ModelType instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelType instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelType instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelType instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelType instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelType instance = element as ModelType;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelType!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelType instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelType instance = element as ModelType;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelType!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer ClassModelElementSerializer for DomainClass ClassModelElement.
	/// </summary>
	public partial class ClassModelElementSerializer : NamedElementSerializer
	{
		#region Constructor
		/// <summary>
		/// ClassModelElementSerializer Constructor
		/// </summary>
		public ClassModelElementSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// Cannot be serialized.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// ClassModelElement is abstract and cannot be instantiated, so this method throws NotSupportedException.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ClassModelElement element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassModelElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			throw new global::System.NotSupportedException();
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ClassModelElement based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ClassModelElement, a new ClassModelElement instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ClassModelElement instance, or null if the reader is not pointing to a serialized ClassModelElement instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "ClassModelElement".
				if (this.derivedClasses == null)
					this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class instance.
					ClassModelElementSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassModelElementSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ClassModelElement based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ClassModelElement.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ClassModelElement instance should be created.</param>	
		/// <returns>Created ClassModelElement instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Abstract class, cannot be serialized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ClassModelElement, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ClassModelElement.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassModelElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ClassModelElement itself) instance of ClassModelElement based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "ClassModelElement".
				if (this.derivedClassMonikers == null)
					this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class moniker instance.
					ClassModelElementSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassModelElementSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ClassModelElement based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				RapidEntitySerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, ClassModelElement.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassModelElement, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassModelElement.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassModelElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ClassModelElement instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassModelElement instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ClassModelElement instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ClassModelElement instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ClassModelElement cannot be monikerized.
			RapidEntitySerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ClassModelElement");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ClassModelElement instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassModelElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ClassModelElement instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassModelElement instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ClassModelElement instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClassModelElement instance = element as ClassModelElement;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClassModelElement!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassModelElement instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClassModelElement instance = element as ClassModelElement;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClassModelElement!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer PersistentKeySerializer for DomainClass PersistentKey.
	/// </summary>
	public partial class PersistentKeySerializer : ModelAttributeSerializer
	{
		#region Constructor
		/// <summary>
		/// PersistentKeySerializer Constructor
		/// </summary>
		public PersistentKeySerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of PersistentKey.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"persistentKey"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of PersistentKey.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"persistentKeyMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of PersistentKey in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one PersistentKey instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the PersistentKey element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory PersistentKey instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory PersistentKey instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			PersistentKey instanceOfPersistentKey = element as PersistentKey;
			global::System.Diagnostics.Debug.Assert(instanceOfPersistentKey != null, "Expecting an instance of PersistentKey");
	
			// IsAutoKey
			if (!serializationContext.Result.Failed)
			{
				string attribIsAutoKey = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isAutoKey");
				if (attribIsAutoKey != null)
				{
					global::System.Boolean valueOfIsAutoKey;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsAutoKey, out valueOfIsAutoKey))
					{
						instanceOfPersistentKey.IsAutoKey = valueOfIsAutoKey;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isAutoKey", typeof(global::System.Boolean), attribIsAutoKey);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of PersistentKey based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized PersistentKey, a new PersistentKey instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created PersistentKey instance, or null if the reader is not pointing to a serialized PersistentKey instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "PersistentKey" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "PersistentKey".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						PersistentKeySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as PersistentKeySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of PersistentKey based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of PersistentKey.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new PersistentKey instance should be created.</param>	
		/// <returns>Created PersistentKey instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new PersistentKey(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from PersistentKey, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from PersistentKey.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(PersistentKey.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including PersistentKey itself) instance of PersistentKey based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "PersistentKey" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "PersistentKey".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						PersistentKeySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as PersistentKeySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of PersistentKey based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				RapidEntitySerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, PersistentKey.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from PersistentKey, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from PersistentKey.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(PersistentKey.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized PersistentKey instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">PersistentKey instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the PersistentKey instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the PersistentKey instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one PersistentKey instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">PersistentKey instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">PersistentKey instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			PersistentKey instanceOfPersistentKey = element as PersistentKey;
			global::System.Diagnostics.Debug.Assert(instanceOfPersistentKey != null, "Expecting an instance of PersistentKey");
	
			// IsAutoKey
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfPersistentKey.IsAutoKey;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isAutoKey", serializedPropValue);
				}
			}
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given PersistentKey instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">PersistentKey instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the PersistentKey instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			PersistentKey instance = element as PersistentKey;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of PersistentKey!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.ModelClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">PersistentKey instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			PersistentKey instance = element as PersistentKey;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of PersistentKey!");
			DslModeling::ModelElement container = instance.ModelClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer ModelAttributeSerializer for DomainClass ModelAttribute.
	/// </summary>
	public partial class ModelAttributeSerializer : ClassModelElementSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelAttributeSerializer Constructor
		/// </summary>
		public ModelAttributeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ModelAttribute.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelAttribute"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ModelAttribute.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelAttributeMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ModelAttribute in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ModelAttribute instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ModelAttribute element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelAttribute instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelAttribute instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			ModelAttribute instanceOfModelAttribute = element as ModelAttribute;
			global::System.Diagnostics.Debug.Assert(instanceOfModelAttribute != null, "Expecting an instance of ModelAttribute");
	
			// Type
			if (!serializationContext.Result.Failed)
			{
				string attribType = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "type");
				if (attribType != null)
				{
					global::System.String valueOfType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribType, out valueOfType))
					{
						instanceOfModelAttribute.Type = valueOfType;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "type", typeof(global::System.String), attribType);
					}
				}
			}
			// ColumnName
			if (!serializationContext.Result.Failed)
			{
				string attribColumnName = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "columnName");
				if (attribColumnName != null)
				{
					global::System.String valueOfColumnName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribColumnName, out valueOfColumnName))
					{
						instanceOfModelAttribute.ColumnName = valueOfColumnName;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "columnName", typeof(global::System.String), attribColumnName);
					}
				}
			}
			// AllowNull
			if (!serializationContext.Result.Failed)
			{
				string attribAllowNull = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "allowNull");
				if (attribAllowNull != null)
				{
					global::System.Boolean valueOfAllowNull;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribAllowNull, out valueOfAllowNull))
					{
						instanceOfModelAttribute.AllowNull = valueOfAllowNull;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "allowNull", typeof(global::System.Boolean), attribAllowNull);
					}
				}
			}
			// Precision
			if (!serializationContext.Result.Failed)
			{
				string attribPrecision = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "precision");
				if (attribPrecision != null)
				{
					global::System.Int32 valueOfPrecision;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Int32>(serializationContext, attribPrecision, out valueOfPrecision))
					{
						instanceOfModelAttribute.Precision = valueOfPrecision;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "precision", typeof(global::System.Int32), attribPrecision);
					}
				}
			}
			// Scale
			if (!serializationContext.Result.Failed)
			{
				string attribScale = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "scale");
				if (attribScale != null)
				{
					global::System.Int32 valueOfScale;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Int32>(serializationContext, attribScale, out valueOfScale))
					{
						instanceOfModelAttribute.Scale = valueOfScale;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "scale", typeof(global::System.Int32), attribScale);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ModelAttribute based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ModelAttribute, a new ModelAttribute instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ModelAttribute instance, or null if the reader is not pointing to a serialized ModelAttribute instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelAttribute" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ModelAttribute".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ModelAttributeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelAttributeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ModelAttribute based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ModelAttribute.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ModelAttribute instance should be created.</param>	
		/// <returns>Created ModelAttribute instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new ModelAttribute(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelAttribute, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelAttribute.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelAttribute.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ModelAttribute itself) instance of ModelAttribute based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelAttribute" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ModelAttribute".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ModelAttributeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelAttributeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ModelAttribute based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				RapidEntitySerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, ModelAttribute.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelAttribute, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelAttribute.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelAttribute.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ModelAttribute instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelAttribute instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ModelAttribute instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelAttribute instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ModelAttribute instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelAttribute instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelAttribute instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			ModelAttribute instanceOfModelAttribute = element as ModelAttribute;
			global::System.Diagnostics.Debug.Assert(instanceOfModelAttribute != null, "Expecting an instance of ModelAttribute");
	
			// Type
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelAttribute.Type;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "type", propValue);
	
				}
			}
			// ColumnName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelAttribute.ColumnName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "columnName", propValue);
	
				}
			}
			// AllowNull
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelAttribute.AllowNull;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "allowNull", serializedPropValue);
				}
			}
			// Precision
			if (!serializationContext.Result.Failed)
			{
				global::System.Int32 propValue = instanceOfModelAttribute.Precision;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Int32>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "precision", serializedPropValue);
				}
			}
			// Scale
			if (!serializationContext.Result.Failed)
			{
				global::System.Int32 propValue = instanceOfModelAttribute.Scale;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Int32>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "scale", serializedPropValue);
				}
			}
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelAttribute instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelAttribute instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelAttribute instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelAttribute instance = element as ModelAttribute;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelAttribute!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelAttribute instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelAttribute instance = element as ModelAttribute;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelAttribute!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer BaseRelationshipSerializer for DomainClass BaseRelationship.
	/// </summary>
	public partial class BaseRelationshipSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// BaseRelationshipSerializer Constructor
		/// </summary>
		public BaseRelationshipSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// Cannot be serialized.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// BaseRelationship is abstract and cannot be instantiated, so this method throws NotSupportedException.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the BaseRelationship element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory BaseRelationship instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// This method reads the target role player Target.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory BaseRelationship instance that will link to the target ModelClass instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player Target
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelClass!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((BaseRelationship)element).Source, BaseRelationship.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, BaseRelationship.TargetDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				RapidEntitySerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "BaseRelationship");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory BaseRelationship instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			BaseRelationship instanceOfBaseRelationship = element as BaseRelationship;
			global::System.Diagnostics.Debug.Assert(instanceOfBaseRelationship != null, "Expecting an instance of BaseRelationship");
	
			// SourceMultiplicity
			if (!serializationContext.Result.Failed)
			{
				string attribSourceMultiplicity = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceMultiplicity");
				if (attribSourceMultiplicity != null)
				{
					Multiplicity valueOfSourceMultiplicity;
					if (DslModeling::SerializationUtilities.TryGetValue<Multiplicity>(serializationContext, attribSourceMultiplicity, out valueOfSourceMultiplicity))
					{
						instanceOfBaseRelationship.SourceMultiplicity = valueOfSourceMultiplicity;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceMultiplicity", typeof(Multiplicity), attribSourceMultiplicity);
					}
				}
			}
			// SourceRoleName
			if (!serializationContext.Result.Failed)
			{
				string attribSourceRoleName = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceRoleName");
				if (attribSourceRoleName != null)
				{
					global::System.String valueOfSourceRoleName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceRoleName, out valueOfSourceRoleName))
					{
						instanceOfBaseRelationship.SourceRoleName = valueOfSourceRoleName;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceRoleName", typeof(global::System.String), attribSourceRoleName);
					}
				}
			}
			// TargetMultiplicity
			if (!serializationContext.Result.Failed)
			{
				string attribTargetMultiplicity = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetMultiplicity");
				if (attribTargetMultiplicity != null)
				{
					Multiplicity valueOfTargetMultiplicity;
					if (DslModeling::SerializationUtilities.TryGetValue<Multiplicity>(serializationContext, attribTargetMultiplicity, out valueOfTargetMultiplicity))
					{
						instanceOfBaseRelationship.TargetMultiplicity = valueOfTargetMultiplicity;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetMultiplicity", typeof(Multiplicity), attribTargetMultiplicity);
					}
				}
			}
			// TargetRoleName
			if (!serializationContext.Result.Failed)
			{
				string attribTargetRoleName = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetRoleName");
				if (attribTargetRoleName != null)
				{
					global::System.String valueOfTargetRoleName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetRoleName, out valueOfTargetRoleName))
					{
						instanceOfBaseRelationship.TargetRoleName = valueOfTargetRoleName;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetRoleName", typeof(global::System.String), attribTargetRoleName);
					}
				}
			}
			// ReferenceColumn
			if (!serializationContext.Result.Failed)
			{
				string attribReferenceColumn = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "referenceColumn");
				if (attribReferenceColumn != null)
				{
					global::System.String valueOfReferenceColumn;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribReferenceColumn, out valueOfReferenceColumn))
					{
						instanceOfBaseRelationship.ReferenceColumn = valueOfReferenceColumn;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "referenceColumn", typeof(global::System.String), attribReferenceColumn);
					}
				}
			}
			// ReferenceEntity
			if (!serializationContext.Result.Failed)
			{
				string attribReferenceEntity = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "referenceEntity");
				if (attribReferenceEntity != null)
				{
					global::System.String valueOfReferenceEntity;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribReferenceEntity, out valueOfReferenceEntity))
					{
						instanceOfBaseRelationship.ReferenceEntity = valueOfReferenceEntity;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "referenceEntity", typeof(global::System.String), attribReferenceEntity);
					}
				}
			}
			// OwnerEntity
			if (!serializationContext.Result.Failed)
			{
				string attribOwnerEntity = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "ownerEntity");
				if (attribOwnerEntity != null)
				{
					global::System.String valueOfOwnerEntity;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribOwnerEntity, out valueOfOwnerEntity))
					{
						instanceOfBaseRelationship.OwnerEntity = valueOfOwnerEntity;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "ownerEntity", typeof(global::System.String), attribOwnerEntity);
					}
				}
			}
			// DefaultRoleName
			if (!serializationContext.Result.Failed)
			{
				string attribDefaultRoleName = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "defaultRoleName");
				if (attribDefaultRoleName != null)
				{
					global::System.String valueOfDefaultRoleName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDefaultRoleName, out valueOfDefaultRoleName))
					{
						instanceOfBaseRelationship.DefaultRoleName = valueOfDefaultRoleName;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "defaultRoleName", typeof(global::System.String), attribDefaultRoleName);
					}
				}
			}
			// ManyRoleName
			if (!serializationContext.Result.Failed)
			{
				string attribManyRoleName = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "manyRoleName");
				if (attribManyRoleName != null)
				{
					global::System.String valueOfManyRoleName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribManyRoleName, out valueOfManyRoleName))
					{
						instanceOfBaseRelationship.ManyRoleName = valueOfManyRoleName;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "manyRoleName", typeof(global::System.String), attribManyRoleName);
					}
				}
			}
			// OneRoleName
			if (!serializationContext.Result.Failed)
			{
				string attribOneRoleName = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "oneRoleName");
				if (attribOneRoleName != null)
				{
					global::System.String valueOfOneRoleName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribOneRoleName, out valueOfOneRoleName))
					{
						instanceOfBaseRelationship.OneRoleName = valueOfOneRoleName;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "oneRoleName", typeof(global::System.String), attribOneRoleName);
					}
				}
			}
			// ReferencedKey
			if (!serializationContext.Result.Failed)
			{
				string attribReferencedKey = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "referencedKey");
				if (attribReferencedKey != null)
				{
					global::System.String valueOfReferencedKey;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribReferencedKey, out valueOfReferencedKey))
					{
						instanceOfBaseRelationship.ReferencedKey = valueOfReferencedKey;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "referencedKey", typeof(global::System.String), attribReferencedKey);
					}
				}
			}
			// Type
			if (!serializationContext.Result.Failed)
			{
				string attribType = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "type");
				if (attribType != null)
				{
					global::System.String valueOfType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribType, out valueOfType))
					{
						instanceOfBaseRelationship.Type = valueOfType;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "type", typeof(global::System.String), attribType);
					}
				}
			}
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of BaseRelationship based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized BaseRelationship, a new BaseRelationship instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created BaseRelationship instance, or null if the reader is not pointing to a serialized BaseRelationship instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "BaseRelationship".
				if (this.derivedClasses == null)
					this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived relationship instance.
					BaseRelationshipSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as BaseRelationshipSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of BaseRelationship based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of BaseRelationship.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new BaseRelationship instance should be created.</param>	
		/// <returns>Created BaseRelationship instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Abstract class, cannot be serialized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// This method creates a correct derived instance of BaseRelationship based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// BaseRelationship type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from BaseRelationship, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{	// Abstract relationship, so it's the same as TryCreateInstance().
			return this.TryCreateInstance(serializationContext, reader, partition) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from BaseRelationship, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from BaseRelationship.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(BaseRelationship.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including BaseRelationship itself) instance of BaseRelationship based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "BaseRelationship".
				if (this.derivedClassMonikers == null)
					this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class moniker instance.
					BaseRelationshipSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as BaseRelationshipSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of BaseRelationship based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				RapidEntitySerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, BaseRelationship.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from BaseRelationship, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from BaseRelationship.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(BaseRelationship.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized BaseRelationship instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">BaseRelationship instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the BaseRelationship instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the BaseRelationship instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of BaseRelationship cannot be monikerized.
			RapidEntitySerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "BaseRelationship");
		}
		
		/// <summary>
		/// Public Write() method that serializes one BaseRelationship instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">BaseRelationship instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">BaseRelationship instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			BaseRelationship instanceOfBaseRelationship = element as BaseRelationship;
			global::System.Diagnostics.Debug.Assert(instanceOfBaseRelationship != null, "Expecting an instance of BaseRelationship");
	
			// SourceMultiplicity
			if (!serializationContext.Result.Failed)
			{
				Multiplicity propValue = instanceOfBaseRelationship.SourceMultiplicity;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<Multiplicity>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, string.Empty) != 0)
					{	// No need to write the value out if it's the same as default value.
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceMultiplicity", serializedPropValue);
					}
				}
			}
			// SourceRoleName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfBaseRelationship.SourceRoleName;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
					{	// No need to write the value out if it's the same as default value.
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceRoleName", propValue);
					}
				}
			}
			// TargetMultiplicity
			if (!serializationContext.Result.Failed)
			{
				Multiplicity propValue = instanceOfBaseRelationship.TargetMultiplicity;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<Multiplicity>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, string.Empty) != 0)
					{	// No need to write the value out if it's the same as default value.
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetMultiplicity", serializedPropValue);
					}
				}
			}
			// TargetRoleName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfBaseRelationship.TargetRoleName;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
					{	// No need to write the value out if it's the same as default value.
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetRoleName", propValue);
					}
				}
			}
			// ReferenceColumn
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfBaseRelationship.ReferenceColumn;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "referenceColumn", propValue);
	
				}
			}
			// ReferenceEntity
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfBaseRelationship.ReferenceEntity;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "referenceEntity", propValue);
	
				}
			}
			// OwnerEntity
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfBaseRelationship.OwnerEntity;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "ownerEntity", propValue);
	
				}
			}
			// DefaultRoleName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfBaseRelationship.DefaultRoleName;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "    ") != 0))
					{	// No need to write the value out if it's the same as default value.
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "defaultRoleName", propValue);
					}
				}
			}
			// ManyRoleName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfBaseRelationship.ManyRoleName;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "0..*") != 0))
					{	// No need to write the value out if it's the same as default value.
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "manyRoleName", propValue);
					}
				}
			}
			// OneRoleName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfBaseRelationship.OneRoleName;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "1") != 0))
					{	// No need to write the value out if it's the same as default value.
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "oneRoleName", propValue);
					}
				}
			}
			// ReferencedKey
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfBaseRelationship.ReferencedKey;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "referencedKey", propValue);
	
				}
			}
			// Type
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfBaseRelationship.Type;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "type", propValue);
	
				}
			}
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given BaseRelationship instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">BaseRelationship instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the BaseRelationship instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			BaseRelationship instance = element as BaseRelationship;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of BaseRelationship!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">BaseRelationship instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of ModelClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, BaseRelationship.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), BaseRelationship.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer ClassHasFieldsSerializer for DomainClass ClassHasFields.
	/// </summary>
	public partial class ClassHasFieldsSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ClassHasFieldsSerializer Constructor
		/// </summary>
		public ClassHasFieldsSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ClassHasFields.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"classHasFields"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ClassHasFields instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ClassHasFields element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassHasFields instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Attribute
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Attribute.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					RapidEntitySerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ClassHasFields");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Attribute.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassHasFields instance that will link to the target Field instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Attribute
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Field.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Field!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, ClassHasFields.AttributeDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				RapidEntitySerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ClassHasFields");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassHasFields instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassHasFields instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of ClassHasFields based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ClassHasFields, a new ClassHasFields instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ClassHasFields instance, or null if the reader is not pointing to a serialized ClassHasFields instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of ClassHasFields based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// ClassHasFields type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from ClassHasFields, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClassHasFields" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ClassHasFields".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						ClassHasFieldsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassHasFieldsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ClassHasFields based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ClassHasFields.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ClassHasFields instance should be created.</param>	
		/// <returns>Created ClassHasFields instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new ClassHasFields(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ClassHasFields.ModelClassDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ClassHasFields.AttributeDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ClassHasFields, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ClassHasFields.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassHasFields.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ClassHasFields itself) instance of ClassHasFields based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClassHasFields" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ClassHasFields".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ClassHasFieldsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassHasFieldsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ClassHasFields based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassHasFields, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassHasFields.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassHasFields.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ClassHasFields instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassHasFields instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ClassHasFields instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ClassHasFields instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ClassHasFields cannot be monikerized.
			RapidEntitySerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ClassHasFields");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ClassHasFields instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassHasFields instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassHasFields instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassHasFields instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ClassHasFields instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassHasFields instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ClassHasFields instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClassHasFields instance = element as ClassHasFields;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClassHasFields!");
	
			DslModeling::ModelElement container = instance.ModelClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassHasFields instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClassHasFields instance = element as ClassHasFields;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClassHasFields!");
			DslModeling::ModelElement container = instance.ModelClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer ModelRootHasCommentsSerializer for DomainClass ModelRootHasComments.
	/// </summary>
	public partial class ModelRootHasCommentsSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelRootHasCommentsSerializer Constructor
		/// </summary>
		public ModelRootHasCommentsSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ModelRootHasComments.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelRootHasComments"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ModelRootHasComments instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ModelRootHasComments element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelRootHasComments instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Comment
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Comment.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					RapidEntitySerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelRootHasComments");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Comment.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelRootHasComments instance that will link to the target Comment instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Comment
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Comment.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Comment!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, ModelRootHasComments.CommentDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				RapidEntitySerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelRootHasComments");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelRootHasComments instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelRootHasComments instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of ModelRootHasComments based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ModelRootHasComments, a new ModelRootHasComments instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ModelRootHasComments instance, or null if the reader is not pointing to a serialized ModelRootHasComments instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of ModelRootHasComments based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// ModelRootHasComments type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from ModelRootHasComments, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelRootHasComments" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ModelRootHasComments".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						ModelRootHasCommentsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelRootHasCommentsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ModelRootHasComments based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ModelRootHasComments.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ModelRootHasComments instance should be created.</param>	
		/// <returns>Created ModelRootHasComments instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new ModelRootHasComments(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelRootHasComments.ModelRootDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelRootHasComments.CommentDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelRootHasComments, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelRootHasComments.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelRootHasComments.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ModelRootHasComments itself) instance of ModelRootHasComments based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelRootHasComments" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ModelRootHasComments".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ModelRootHasCommentsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelRootHasCommentsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ModelRootHasComments based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelRootHasComments, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelRootHasComments.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelRootHasComments.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ModelRootHasComments instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelRootHasComments instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ModelRootHasComments instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelRootHasComments instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ModelRootHasComments cannot be monikerized.
			RapidEntitySerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ModelRootHasComments");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ModelRootHasComments instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelRootHasComments instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelRootHasComments instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelRootHasComments instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelRootHasComments instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelRootHasComments instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelRootHasComments instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelRootHasComments instance = element as ModelRootHasComments;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelRootHasComments!");
	
			DslModeling::ModelElement container = instance.ModelRoot;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelRootHasComments instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelRootHasComments instance = element as ModelRootHasComments;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelRootHasComments!");
			DslModeling::ModelElement container = instance.ModelRoot;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer GeneralizationSerializer for DomainClass Generalization.
	/// </summary>
	public partial class GeneralizationSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// GeneralizationSerializer Constructor
		/// </summary>
		public GeneralizationSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Generalization.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"generalization"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Generalization instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Generalization element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Generalization instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements, which include at least the monikerized instance of target role-player Subclass
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Subclass.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					RapidEntitySerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "Generalization");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Subclass.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Generalization instance that will link to the target ModelClass instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player Subclass
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelClass!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((Generalization)element).Superclass, Generalization.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, Generalization.SubclassDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				RapidEntitySerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "Generalization");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Generalization instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			Generalization instanceOfGeneralization = element as Generalization;
			global::System.Diagnostics.Debug.Assert(instanceOfGeneralization != null, "Expecting an instance of Generalization");
	
			// Discriminator
			if (!serializationContext.Result.Failed)
			{
				string attribDiscriminator = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "discriminator");
				if (attribDiscriminator != null)
				{
					global::System.String valueOfDiscriminator;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDiscriminator, out valueOfDiscriminator))
					{
						instanceOfGeneralization.Discriminator = valueOfDiscriminator;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "discriminator", typeof(global::System.String), attribDiscriminator);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Generalization instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of Generalization based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Generalization, a new Generalization instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Generalization instance, or null if the reader is not pointing to a serialized Generalization instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of Generalization based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// Generalization type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from Generalization, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Generalization" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Generalization".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						GeneralizationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as GeneralizationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Generalization based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Generalization.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Generalization instance should be created.</param>	
		/// <returns>Created Generalization instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new Generalization(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (Generalization.SuperclassDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (Generalization.SubclassDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Generalization, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Generalization.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Generalization.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Generalization itself) instance of Generalization based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Generalization" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Generalization".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						GeneralizationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as GeneralizationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Generalization based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Generalization, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Generalization.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Generalization.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Generalization instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Generalization instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Generalization instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Generalization instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of Generalization cannot be monikerized.
			RapidEntitySerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "Generalization");
		}
		
		/// <summary>
		/// Public Write() method that serializes one Generalization instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Generalization instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			Generalization instance = element as Generalization;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Generalization!");
	
			DslModeling::ModelElement targetElement = instance.Subclass;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.Superclass, this);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Generalization instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			Generalization instanceOfGeneralization = element as Generalization;
			global::System.Diagnostics.Debug.Assert(instanceOfGeneralization != null, "Expecting an instance of Generalization");
	
			// Discriminator
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfGeneralization.Discriminator;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
					{	// No need to write the value out if it's the same as default value.
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "discriminator", propValue);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Generalization instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Generalization instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Generalization instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Generalization instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Generalization instance = element as Generalization;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Generalization!");
	
			DslModeling::ModelElement container = instance.Superclass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Generalization instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Generalization instance = element as Generalization;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Generalization!");
			DslModeling::ModelElement container = instance.Superclass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of ModelClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, Generalization.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), Generalization.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer OneToOneSerializer for DomainClass OneToOne.
	/// </summary>
	public partial class OneToOneSerializer : BaseRelationshipSerializer
	{
		#region Constructor
		/// <summary>
		/// OneToOneSerializer Constructor
		/// </summary>
		public OneToOneSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of OneToOne.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"oneToOne"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of OneToOne.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"oneToOneMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of OneToOne in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one OneToOne instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the OneToOne element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory OneToOne instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements, which include at least the monikerized instance of target role-player BidirectionalTarget
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player BidirectionalTarget.
					base.ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					RapidEntitySerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "OneToOne");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory OneToOne instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			OneToOne instanceOfOneToOne = element as OneToOne;
			global::System.Diagnostics.Debug.Assert(instanceOfOneToOne != null, "Expecting an instance of OneToOne");
	
			// RelationColumn
			if (!serializationContext.Result.Failed)
			{
				string attribRelationColumn = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "relationColumn");
				if (attribRelationColumn != null)
				{
					global::System.String valueOfRelationColumn;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribRelationColumn, out valueOfRelationColumn))
					{
						instanceOfOneToOne.RelationColumn = valueOfRelationColumn;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "relationColumn", typeof(global::System.String), attribRelationColumn);
					}
				}
			}
			// Cascade
			if (!serializationContext.Result.Failed)
			{
				string attribCascade = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "cascade");
				if (attribCascade != null)
				{
					global::System.String valueOfCascade;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCascade, out valueOfCascade))
					{
						instanceOfOneToOne.Cascade = valueOfCascade;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "cascade", typeof(global::System.String), attribCascade);
					}
				}
			}
			// IsImported
			if (!serializationContext.Result.Failed)
			{
				string attribIsImported = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isImported");
				if (attribIsImported != null)
				{
					global::System.Boolean valueOfIsImported;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsImported, out valueOfIsImported))
					{
						instanceOfOneToOne.IsImported = valueOfIsImported;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isImported", typeof(global::System.Boolean), attribIsImported);
					}
				}
			}
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of OneToOne based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized OneToOne, a new OneToOne instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created OneToOne instance, or null if the reader is not pointing to a serialized OneToOne instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of OneToOne based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// OneToOne type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from OneToOne, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "OneToOne" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "OneToOne".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						OneToOneSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as OneToOneSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of OneToOne based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of OneToOne.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new OneToOne instance should be created.</param>	
		/// <returns>Created OneToOne instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					RapidEntitySerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new OneToOne(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (OneToOne.BidirectionalSourceDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (OneToOne.BidirectionalTargetDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from OneToOne, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from OneToOne.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(OneToOne.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including OneToOne itself) instance of OneToOne based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "OneToOne" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "OneToOne".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						OneToOneSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as OneToOneSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of OneToOne based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				RapidEntitySerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, OneToOne.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from OneToOne, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from OneToOne.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(OneToOne.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized OneToOne instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToOne instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the OneToOne instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the OneToOne instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one OneToOne instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToOne instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			OneToOne instance = element as OneToOne;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of OneToOne!");
	
			DslModeling::ModelElement targetElement = instance.BidirectionalTarget;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.BidirectionalSource, this);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToOne instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			OneToOne instanceOfOneToOne = element as OneToOne;
			global::System.Diagnostics.Debug.Assert(instanceOfOneToOne != null, "Expecting an instance of OneToOne");
	
			// RelationColumn
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfOneToOne.RelationColumn;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "relationColumn", propValue);
	
				}
			}
			// Cascade
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfOneToOne.Cascade;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "Cascade.NOTSET") != 0))
					{	// No need to write the value out if it's the same as default value.
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "cascade", propValue);
					}
				}
			}
			// IsImported
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfOneToOne.IsImported;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isImported", serializedPropValue);
				}
			}
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given OneToOne instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">OneToOne instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the OneToOne instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			OneToOne instance = element as OneToOne;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of OneToOne!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">OneToOne instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of ModelClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, OneToOne.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), OneToOne.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer OneToManySerializer for DomainClass OneToMany.
	/// </summary>
	public partial class OneToManySerializer : BaseRelationshipSerializer
	{
		#region Constructor
		/// <summary>
		/// OneToManySerializer Constructor
		/// </summary>
		public OneToManySerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of OneToMany.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"oneToMany"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of OneToMany.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"oneToManyMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of OneToMany in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one OneToMany instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the OneToMany element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory OneToMany instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements, which include at least the monikerized instance of target role-player AggregationTarget
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player AggregationTarget.
					base.ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					RapidEntitySerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "OneToMany");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory OneToMany instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			OneToMany instanceOfOneToMany = element as OneToMany;
			global::System.Diagnostics.Debug.Assert(instanceOfOneToMany != null, "Expecting an instance of OneToMany");
	
			// RelationColumn
			if (!serializationContext.Result.Failed)
			{
				string attribRelationColumn = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "relationColumn");
				if (attribRelationColumn != null)
				{
					global::System.String valueOfRelationColumn;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribRelationColumn, out valueOfRelationColumn))
					{
						instanceOfOneToMany.RelationColumn = valueOfRelationColumn;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "relationColumn", typeof(global::System.String), attribRelationColumn);
					}
				}
			}
			// Cascade
			if (!serializationContext.Result.Failed)
			{
				string attribCascade = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "cascade");
				if (attribCascade != null)
				{
					global::System.String valueOfCascade;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCascade, out valueOfCascade))
					{
						instanceOfOneToMany.Cascade = valueOfCascade;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "cascade", typeof(global::System.String), attribCascade);
					}
				}
			}
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of OneToMany based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized OneToMany, a new OneToMany instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created OneToMany instance, or null if the reader is not pointing to a serialized OneToMany instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of OneToMany based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// OneToMany type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from OneToMany, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "OneToMany" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "OneToMany".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						OneToManySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as OneToManySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of OneToMany based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of OneToMany.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new OneToMany instance should be created.</param>	
		/// <returns>Created OneToMany instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					RapidEntitySerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new OneToMany(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (OneToMany.AggregationSourceDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (OneToMany.AggregationTargetDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from OneToMany, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from OneToMany.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(OneToMany.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including OneToMany itself) instance of OneToMany based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "OneToMany" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "OneToMany".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						OneToManySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as OneToManySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of OneToMany based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				RapidEntitySerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, OneToMany.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from OneToMany, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from OneToMany.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(OneToMany.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized OneToMany instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToMany instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the OneToMany instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the OneToMany instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one OneToMany instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToMany instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			OneToMany instance = element as OneToMany;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of OneToMany!");
	
			DslModeling::ModelElement targetElement = instance.AggregationTarget;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.AggregationSource, this);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToMany instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			OneToMany instanceOfOneToMany = element as OneToMany;
			global::System.Diagnostics.Debug.Assert(instanceOfOneToMany != null, "Expecting an instance of OneToMany");
	
			// RelationColumn
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfOneToMany.RelationColumn;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "relationColumn", propValue);
	
				}
			}
			// Cascade
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfOneToMany.Cascade;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "Cascade.NOTSET") != 0))
					{	// No need to write the value out if it's the same as default value.
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "cascade", propValue);
					}
				}
			}
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given OneToMany instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">OneToMany instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the OneToMany instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			OneToMany instance = element as OneToMany;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of OneToMany!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">OneToMany instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of ModelClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, OneToMany.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), OneToMany.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer ModelRootHasTypesSerializer for DomainClass ModelRootHasTypes.
	/// </summary>
	public partial class ModelRootHasTypesSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelRootHasTypesSerializer Constructor
		/// </summary>
		public ModelRootHasTypesSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ModelRootHasTypes.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelRootHasTypes"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ModelRootHasTypes instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ModelRootHasTypes element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelRootHasTypes instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Type
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Type.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					RapidEntitySerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelRootHasTypes");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Type.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelRootHasTypes instance that will link to the target ModelType instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Type
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelType.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelType!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, ModelRootHasTypes.TypeDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				RapidEntitySerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelRootHasTypes");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelRootHasTypes instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelRootHasTypes instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of ModelRootHasTypes based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ModelRootHasTypes, a new ModelRootHasTypes instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ModelRootHasTypes instance, or null if the reader is not pointing to a serialized ModelRootHasTypes instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of ModelRootHasTypes based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// ModelRootHasTypes type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from ModelRootHasTypes, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelRootHasTypes" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ModelRootHasTypes".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						ModelRootHasTypesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelRootHasTypesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ModelRootHasTypes based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ModelRootHasTypes.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ModelRootHasTypes instance should be created.</param>	
		/// <returns>Created ModelRootHasTypes instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new ModelRootHasTypes(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelRootHasTypes.ModelRootDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelRootHasTypes.TypeDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelRootHasTypes, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelRootHasTypes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelRootHasTypes.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ModelRootHasTypes itself) instance of ModelRootHasTypes based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelRootHasTypes" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ModelRootHasTypes".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ModelRootHasTypesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelRootHasTypesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ModelRootHasTypes based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelRootHasTypes, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelRootHasTypes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelRootHasTypes.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ModelRootHasTypes instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelRootHasTypes instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ModelRootHasTypes instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelRootHasTypes instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ModelRootHasTypes cannot be monikerized.
			RapidEntitySerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ModelRootHasTypes");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ModelRootHasTypes instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelRootHasTypes instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelRootHasTypes instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelRootHasTypes instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelRootHasTypes instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelRootHasTypes instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelRootHasTypes instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelRootHasTypes instance = element as ModelRootHasTypes;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelRootHasTypes!");
	
			DslModeling::ModelElement container = instance.ModelRoot;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelRootHasTypes instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelRootHasTypes instance = element as ModelRootHasTypes;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelRootHasTypes!");
			DslModeling::ModelElement container = instance.ModelRoot;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer CommentReferencesSubjectsSerializer for DomainClass CommentReferencesSubjects.
	/// </summary>
	public partial class CommentReferencesSubjectsSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// CommentReferencesSubjectsSerializer Constructor
		/// </summary>
		public CommentReferencesSubjectsSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of CommentReferencesSubjects.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"commentReferencesSubjects"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one CommentReferencesSubjects instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the CommentReferencesSubjects element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory CommentReferencesSubjects instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the monikerized instance of target role-player Subject
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Subject.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					RapidEntitySerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "CommentReferencesSubjects");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Subject.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory CommentReferencesSubjects instance that will link to the target ModelType instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player Subject
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelType.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelType!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((CommentReferencesSubjects)element).Comment, CommentReferencesSubjects.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, CommentReferencesSubjects.SubjectDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				RapidEntitySerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "CommentReferencesSubjects");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory CommentReferencesSubjects instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory CommentReferencesSubjects instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of CommentReferencesSubjects based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized CommentReferencesSubjects, a new CommentReferencesSubjects instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created CommentReferencesSubjects instance, or null if the reader is not pointing to a serialized CommentReferencesSubjects instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of CommentReferencesSubjects based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// CommentReferencesSubjects type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from CommentReferencesSubjects, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "CommentReferencesSubjects" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "CommentReferencesSubjects".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						CommentReferencesSubjectsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentReferencesSubjectsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of CommentReferencesSubjects based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of CommentReferencesSubjects.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new CommentReferencesSubjects instance should be created.</param>	
		/// <returns>Created CommentReferencesSubjects instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new CommentReferencesSubjects(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (CommentReferencesSubjects.CommentDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (CommentReferencesSubjects.SubjectDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from CommentReferencesSubjects, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from CommentReferencesSubjects.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(CommentReferencesSubjects.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including CommentReferencesSubjects itself) instance of CommentReferencesSubjects based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "CommentReferencesSubjects" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "CommentReferencesSubjects".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						CommentReferencesSubjectsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentReferencesSubjectsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of CommentReferencesSubjects based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from CommentReferencesSubjects, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from CommentReferencesSubjects.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(CommentReferencesSubjects.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized CommentReferencesSubjects instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">CommentReferencesSubjects instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the CommentReferencesSubjects instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the CommentReferencesSubjects instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of CommentReferencesSubjects cannot be monikerized.
			RapidEntitySerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "CommentReferencesSubjects");
		}
		
		/// <summary>
		/// Public Write() method that serializes one CommentReferencesSubjects instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">CommentReferencesSubjects instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">CommentReferencesSubjects instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">CommentReferencesSubjects instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given CommentReferencesSubjects instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">CommentReferencesSubjects instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the CommentReferencesSubjects instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			CommentReferencesSubjects instance = element as CommentReferencesSubjects;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of CommentReferencesSubjects!");
	
			DslModeling::ModelElement container = instance.Comment;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">CommentReferencesSubjects instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			CommentReferencesSubjects instance = element as CommentReferencesSubjects;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of CommentReferencesSubjects!");
			DslModeling::ModelElement container = instance.Comment;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelType
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of Comment that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelType</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelType instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is Comment, "Expecting an instance of Comment!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, CommentReferencesSubjects.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), CommentReferencesSubjects.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelType.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is Comment, "Expecting an instance of Comment!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelType, "Expecting an instance of ModelType!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer ManyToManySerializer for DomainClass ManyToMany.
	/// </summary>
	public partial class ManyToManySerializer : BaseRelationshipSerializer
	{
		#region Constructor
		/// <summary>
		/// ManyToManySerializer Constructor
		/// </summary>
		public ManyToManySerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ManyToMany.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"manyToMany"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ManyToMany.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"manyToManyMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ManyToMany in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ManyToMany instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ManyToMany element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToMany instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements, which include at least the monikerized instance of target role-player TargetModelClass
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player TargetModelClass.
					base.ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					RapidEntitySerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ManyToMany");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToMany instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			ManyToMany instanceOfManyToMany = element as ManyToMany;
			global::System.Diagnostics.Debug.Assert(instanceOfManyToMany != null, "Expecting an instance of ManyToMany");
	
			// JoinTable
			if (!serializationContext.Result.Failed)
			{
				string attribJoinTable = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "joinTable");
				if (attribJoinTable != null)
				{
					global::System.String valueOfJoinTable;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribJoinTable, out valueOfJoinTable))
					{
						instanceOfManyToMany.JoinTable = valueOfJoinTable;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "joinTable", typeof(global::System.String), attribJoinTable);
					}
				}
			}
			// JoinColumn
			if (!serializationContext.Result.Failed)
			{
				string attribJoinColumn = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "joinColumn");
				if (attribJoinColumn != null)
				{
					global::System.String valueOfJoinColumn;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribJoinColumn, out valueOfJoinColumn))
					{
						instanceOfManyToMany.JoinColumn = valueOfJoinColumn;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "joinColumn", typeof(global::System.String), attribJoinColumn);
					}
				}
			}
			// OwnerColumn
			if (!serializationContext.Result.Failed)
			{
				string attribOwnerColumn = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "ownerColumn");
				if (attribOwnerColumn != null)
				{
					global::System.String valueOfOwnerColumn;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribOwnerColumn, out valueOfOwnerColumn))
					{
						instanceOfManyToMany.OwnerColumn = valueOfOwnerColumn;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "ownerColumn", typeof(global::System.String), attribOwnerColumn);
					}
				}
			}
			// Cascade
			if (!serializationContext.Result.Failed)
			{
				string attribCascade = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "cascade");
				if (attribCascade != null)
				{
					global::System.String valueOfCascade;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCascade, out valueOfCascade))
					{
						instanceOfManyToMany.Cascade = valueOfCascade;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "cascade", typeof(global::System.String), attribCascade);
					}
				}
			}
			// OwnerKey
			if (!serializationContext.Result.Failed)
			{
				string attribOwnerKey = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "ownerKey");
				if (attribOwnerKey != null)
				{
					global::System.String valueOfOwnerKey;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribOwnerKey, out valueOfOwnerKey))
					{
						instanceOfManyToMany.OwnerKey = valueOfOwnerKey;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "ownerKey", typeof(global::System.String), attribOwnerKey);
					}
				}
			}
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of ManyToMany based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ManyToMany, a new ManyToMany instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ManyToMany instance, or null if the reader is not pointing to a serialized ManyToMany instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of ManyToMany based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// ManyToMany type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from ManyToMany, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToMany" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ManyToMany".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						ManyToManySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToManySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ManyToMany based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ManyToMany.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ManyToMany instance should be created.</param>	
		/// <returns>Created ManyToMany instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					RapidEntitySerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new ManyToMany(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ManyToMany.SourceModelClassDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ManyToMany.TargetModelClassDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ManyToMany, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ManyToMany.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToMany.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ManyToMany itself) instance of ManyToMany based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToMany" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ManyToMany".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ManyToManySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToManySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ManyToMany based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				RapidEntitySerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ManyToMany.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToMany, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToMany.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToMany.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ManyToMany instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToMany instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ManyToMany instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ManyToMany instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ManyToMany instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToMany instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			ManyToMany instance = element as ManyToMany;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToMany!");
	
			DslModeling::ModelElement targetElement = instance.TargetModelClass;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.SourceModelClass, this);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToMany instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			ManyToMany instanceOfManyToMany = element as ManyToMany;
			global::System.Diagnostics.Debug.Assert(instanceOfManyToMany != null, "Expecting an instance of ManyToMany");
	
			// JoinTable
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToMany.JoinTable;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "joinTable", propValue);
	
				}
			}
			// JoinColumn
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToMany.JoinColumn;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "joinColumn", propValue);
	
				}
			}
			// OwnerColumn
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToMany.OwnerColumn;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "ownerColumn", propValue);
	
				}
			}
			// Cascade
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToMany.Cascade;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "Cascade.NOTSET") != 0))
					{	// No need to write the value out if it's the same as default value.
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "cascade", propValue);
					}
				}
			}
			// OwnerKey
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToMany.OwnerKey;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "ownerKey", propValue);
	
				}
			}
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ManyToMany instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToMany instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ManyToMany instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ManyToMany instance = element as ManyToMany;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToMany!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToMany instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of ModelClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, ManyToMany.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), ManyToMany.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer ClassHasPersistentKeysSerializer for DomainClass ClassHasPersistentKeys.
	/// </summary>
	public partial class ClassHasPersistentKeysSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ClassHasPersistentKeysSerializer Constructor
		/// </summary>
		public ClassHasPersistentKeysSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ClassHasPersistentKeys.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"classHasPersistentKeys"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ClassHasPersistentKeys instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ClassHasPersistentKeys element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassHasPersistentKeys instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player PersistentKey
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player PersistentKey.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					RapidEntitySerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ClassHasPersistentKeys");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player PersistentKey.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassHasPersistentKeys instance that will link to the target PersistentKey instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player PersistentKey
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(PersistentKey.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for PersistentKey!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, ClassHasPersistentKeys.PersistentKeyDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				RapidEntitySerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ClassHasPersistentKeys");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassHasPersistentKeys instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassHasPersistentKeys instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of ClassHasPersistentKeys based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ClassHasPersistentKeys, a new ClassHasPersistentKeys instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ClassHasPersistentKeys instance, or null if the reader is not pointing to a serialized ClassHasPersistentKeys instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of ClassHasPersistentKeys based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// ClassHasPersistentKeys type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from ClassHasPersistentKeys, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClassHasPersistentKeys" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ClassHasPersistentKeys".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						ClassHasPersistentKeysSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassHasPersistentKeysSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ClassHasPersistentKeys based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ClassHasPersistentKeys.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ClassHasPersistentKeys instance should be created.</param>	
		/// <returns>Created ClassHasPersistentKeys instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new ClassHasPersistentKeys(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ClassHasPersistentKeys.ModelClassDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ClassHasPersistentKeys.PersistentKeyDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ClassHasPersistentKeys, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ClassHasPersistentKeys.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassHasPersistentKeys.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ClassHasPersistentKeys itself) instance of ClassHasPersistentKeys based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClassHasPersistentKeys" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ClassHasPersistentKeys".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ClassHasPersistentKeysSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassHasPersistentKeysSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ClassHasPersistentKeys based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassHasPersistentKeys, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassHasPersistentKeys.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassHasPersistentKeys.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ClassHasPersistentKeys instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassHasPersistentKeys instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ClassHasPersistentKeys instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ClassHasPersistentKeys instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ClassHasPersistentKeys cannot be monikerized.
			RapidEntitySerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ClassHasPersistentKeys");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ClassHasPersistentKeys instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassHasPersistentKeys instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassHasPersistentKeys instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassHasPersistentKeys instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ClassHasPersistentKeys instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassHasPersistentKeys instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ClassHasPersistentKeys instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClassHasPersistentKeys instance = element as ClassHasPersistentKeys;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClassHasPersistentKeys!");
	
			DslModeling::ModelElement container = instance.ModelClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassHasPersistentKeys instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClassHasPersistentKeys instance = element as ClassHasPersistentKeys;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClassHasPersistentKeys!");
			DslModeling::ModelElement container = instance.ModelClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer ClassShapeSerializer for DomainClass ClassShape.
	/// </summary>
	public partial class ClassShapeSerializer : DslDiagrams::CompartmentShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// ClassShapeSerializer Constructor
		/// </summary>
		public ClassShapeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ClassShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"classShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ClassShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"classShapeMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ClassShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ClassShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ClassShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ClassShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ClassShape, a new ClassShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ClassShape instance, or null if the reader is not pointing to a serialized ClassShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClassShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ClassShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ClassShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ClassShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ClassShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ClassShape instance should be created.</param>	
		/// <returns>Created ClassShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					RapidEntitySerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new ClassShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ClassShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ClassShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ClassShape itself) instance of ClassShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClassShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ClassShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ClassShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ClassShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				RapidEntitySerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ClassShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ClassShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ClassShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ClassShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ClassShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ClassShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ClassShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClassShape instance = element as ClassShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClassShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer CommentBoxShapeSerializer for DomainClass CommentBoxShape.
	/// </summary>
	public partial class CommentBoxShapeSerializer : DslDiagrams::NodeShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// CommentBoxShapeSerializer Constructor
		/// </summary>
		public CommentBoxShapeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of CommentBoxShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"commentBoxShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of CommentBoxShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"commentBoxShapeMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of CommentBoxShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one CommentBoxShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the CommentBoxShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory CommentBoxShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of CommentBoxShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized CommentBoxShape, a new CommentBoxShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created CommentBoxShape instance, or null if the reader is not pointing to a serialized CommentBoxShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "CommentBoxShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "CommentBoxShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						CommentBoxShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentBoxShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of CommentBoxShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of CommentBoxShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new CommentBoxShape instance should be created.</param>	
		/// <returns>Created CommentBoxShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					RapidEntitySerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new CommentBoxShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from CommentBoxShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from CommentBoxShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(CommentBoxShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including CommentBoxShape itself) instance of CommentBoxShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "CommentBoxShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "CommentBoxShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						CommentBoxShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentBoxShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of CommentBoxShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				RapidEntitySerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, CommentBoxShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				RapidEntitySerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from CommentBoxShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from CommentBoxShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(CommentBoxShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized CommentBoxShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">CommentBoxShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the CommentBoxShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the CommentBoxShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one CommentBoxShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">CommentBoxShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given CommentBoxShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">CommentBoxShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the CommentBoxShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			CommentBoxShape instance = element as CommentBoxShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of CommentBoxShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">CommentBoxShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer RelationshipConnectorSerializer for DomainClass RelationshipConnector.
	/// </summary>
	public partial class RelationshipConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// RelationshipConnectorSerializer Constructor
		/// </summary>
		public RelationshipConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// Cannot be serialized.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// RelationshipConnector is abstract and cannot be instantiated, so this method throws NotSupportedException.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the RelationshipConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory RelationshipConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			throw new global::System.NotSupportedException();
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of RelationshipConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized RelationshipConnector, a new RelationshipConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created RelationshipConnector instance, or null if the reader is not pointing to a serialized RelationshipConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "RelationshipConnector".
				if (this.derivedClasses == null)
					this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class instance.
					RelationshipConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as RelationshipConnectorSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of RelationshipConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of RelationshipConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new RelationshipConnector instance should be created.</param>	
		/// <returns>Created RelationshipConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Abstract class, cannot be serialized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from RelationshipConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from RelationshipConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(RelationshipConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including RelationshipConnector itself) instance of RelationshipConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "RelationshipConnector".
				if (this.derivedClassMonikers == null)
					this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class moniker instance.
					RelationshipConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as RelationshipConnectorSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of RelationshipConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from RelationshipConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from RelationshipConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(RelationshipConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized RelationshipConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">RelationshipConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the RelationshipConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the RelationshipConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of RelationshipConnector cannot be monikerized.
			RapidEntitySerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "RelationshipConnector");
		}
		
		/// <summary>
		/// Public Write() method that serializes one RelationshipConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">RelationshipConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given RelationshipConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">RelationshipConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the RelationshipConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			RelationshipConnector instance = element as RelationshipConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of RelationshipConnector!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">RelationshipConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			RelationshipConnector instance = element as RelationshipConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of RelationshipConnector!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer BidirectionalConnectorSerializer for DomainClass BidirectionalConnector.
	/// </summary>
	public partial class BidirectionalConnectorSerializer : RelationshipConnectorSerializer
	{
		#region Constructor
		/// <summary>
		/// BidirectionalConnectorSerializer Constructor
		/// </summary>
		public BidirectionalConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of BidirectionalConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"bidirectionalConnector"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one BidirectionalConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the BidirectionalConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory BidirectionalConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of BidirectionalConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized BidirectionalConnector, a new BidirectionalConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created BidirectionalConnector instance, or null if the reader is not pointing to a serialized BidirectionalConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "BidirectionalConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "BidirectionalConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						BidirectionalConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as BidirectionalConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of BidirectionalConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of BidirectionalConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new BidirectionalConnector instance should be created.</param>	
		/// <returns>Created BidirectionalConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new BidirectionalConnector(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from BidirectionalConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from BidirectionalConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(BidirectionalConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including BidirectionalConnector itself) instance of BidirectionalConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "BidirectionalConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "BidirectionalConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						BidirectionalConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as BidirectionalConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of BidirectionalConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from BidirectionalConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from BidirectionalConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(BidirectionalConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized BidirectionalConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">BidirectionalConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the BidirectionalConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the BidirectionalConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of BidirectionalConnector cannot be monikerized.
			RapidEntitySerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "BidirectionalConnector");
		}
		
		/// <summary>
		/// Public Write() method that serializes one BidirectionalConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">BidirectionalConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given BidirectionalConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">BidirectionalConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the BidirectionalConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			BidirectionalConnector instance = element as BidirectionalConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of BidirectionalConnector!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">BidirectionalConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			BidirectionalConnector instance = element as BidirectionalConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of BidirectionalConnector!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer AggregationConnectorSerializer for DomainClass AggregationConnector.
	/// </summary>
	public partial class AggregationConnectorSerializer : RelationshipConnectorSerializer
	{
		#region Constructor
		/// <summary>
		/// AggregationConnectorSerializer Constructor
		/// </summary>
		public AggregationConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of AggregationConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"aggregationConnector"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one AggregationConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the AggregationConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory AggregationConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of AggregationConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized AggregationConnector, a new AggregationConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created AggregationConnector instance, or null if the reader is not pointing to a serialized AggregationConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "AggregationConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "AggregationConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						AggregationConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as AggregationConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of AggregationConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of AggregationConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new AggregationConnector instance should be created.</param>	
		/// <returns>Created AggregationConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new AggregationConnector(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from AggregationConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from AggregationConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(AggregationConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including AggregationConnector itself) instance of AggregationConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "AggregationConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "AggregationConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						AggregationConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as AggregationConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of AggregationConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from AggregationConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from AggregationConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(AggregationConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized AggregationConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">AggregationConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the AggregationConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the AggregationConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of AggregationConnector cannot be monikerized.
			RapidEntitySerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "AggregationConnector");
		}
		
		/// <summary>
		/// Public Write() method that serializes one AggregationConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">AggregationConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given AggregationConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">AggregationConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the AggregationConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			AggregationConnector instance = element as AggregationConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of AggregationConnector!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">AggregationConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			AggregationConnector instance = element as AggregationConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of AggregationConnector!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer GeneralizationConnectorSerializer for DomainClass GeneralizationConnector.
	/// </summary>
	public partial class GeneralizationConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// GeneralizationConnectorSerializer Constructor
		/// </summary>
		public GeneralizationConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of GeneralizationConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"generalizationConnector"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one GeneralizationConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the GeneralizationConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory GeneralizationConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of GeneralizationConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized GeneralizationConnector, a new GeneralizationConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created GeneralizationConnector instance, or null if the reader is not pointing to a serialized GeneralizationConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "GeneralizationConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "GeneralizationConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						GeneralizationConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as GeneralizationConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of GeneralizationConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of GeneralizationConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new GeneralizationConnector instance should be created.</param>	
		/// <returns>Created GeneralizationConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new GeneralizationConnector(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from GeneralizationConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from GeneralizationConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(GeneralizationConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including GeneralizationConnector itself) instance of GeneralizationConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "GeneralizationConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "GeneralizationConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						GeneralizationConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as GeneralizationConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of GeneralizationConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from GeneralizationConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from GeneralizationConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(GeneralizationConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized GeneralizationConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">GeneralizationConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the GeneralizationConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the GeneralizationConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of GeneralizationConnector cannot be monikerized.
			RapidEntitySerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "GeneralizationConnector");
		}
		
		/// <summary>
		/// Public Write() method that serializes one GeneralizationConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">GeneralizationConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given GeneralizationConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">GeneralizationConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the GeneralizationConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			GeneralizationConnector instance = element as GeneralizationConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of GeneralizationConnector!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">GeneralizationConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			GeneralizationConnector instance = element as GeneralizationConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of GeneralizationConnector!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer CommentConnectorSerializer for DomainClass CommentConnector.
	/// </summary>
	public partial class CommentConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// CommentConnectorSerializer Constructor
		/// </summary>
		public CommentConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of CommentConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"commentConnector"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one CommentConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the CommentConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory CommentConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of CommentConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized CommentConnector, a new CommentConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created CommentConnector instance, or null if the reader is not pointing to a serialized CommentConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "CommentConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "CommentConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						CommentConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of CommentConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of CommentConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new CommentConnector instance should be created.</param>	
		/// <returns>Created CommentConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new CommentConnector(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from CommentConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from CommentConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(CommentConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including CommentConnector itself) instance of CommentConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "CommentConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "CommentConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						CommentConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of CommentConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from CommentConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from CommentConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(CommentConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized CommentConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">CommentConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the CommentConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the CommentConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of CommentConnector cannot be monikerized.
			RapidEntitySerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "CommentConnector");
		}
		
		/// <summary>
		/// Public Write() method that serializes one CommentConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">CommentConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given CommentConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">CommentConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the CommentConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			CommentConnector instance = element as CommentConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of CommentConnector!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">CommentConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			CommentConnector instance = element as CommentConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of CommentConnector!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer ManyToManyConnectorSerializer for DomainClass ManyToManyConnector.
	/// </summary>
	public partial class ManyToManyConnectorSerializer : RelationshipConnectorSerializer
	{
		#region Constructor
		/// <summary>
		/// ManyToManyConnectorSerializer Constructor
		/// </summary>
		public ManyToManyConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ManyToManyConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"manyToManyConnector"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ManyToManyConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ManyToManyConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToManyConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ManyToManyConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ManyToManyConnector, a new ManyToManyConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ManyToManyConnector instance, or null if the reader is not pointing to a serialized ManyToManyConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToManyConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ManyToManyConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ManyToManyConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToManyConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ManyToManyConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ManyToManyConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ManyToManyConnector instance should be created.</param>	
		/// <returns>Created ManyToManyConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new ManyToManyConnector(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ManyToManyConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ManyToManyConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToManyConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ManyToManyConnector itself) instance of ManyToManyConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToManyConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ManyToManyConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ManyToManyConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToManyConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ManyToManyConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToManyConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToManyConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToManyConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ManyToManyConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToManyConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ManyToManyConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ManyToManyConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ManyToManyConnector cannot be monikerized.
			RapidEntitySerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ManyToManyConnector");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ManyToManyConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToManyConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ManyToManyConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToManyConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ManyToManyConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ManyToManyConnector instance = element as ManyToManyConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToManyConnector!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToManyConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ManyToManyConnector instance = element as ManyToManyConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToManyConnector!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Serializer ClassDiagramSerializer for DomainClass ClassDiagram.
	/// </summary>
	public partial class ClassDiagramSerializer : DslDiagrams::DiagramSerializer
	{
		#region Constructor
		/// <summary>
		/// ClassDiagramSerializer Constructor
		/// </summary>
		public ClassDiagramSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ClassDiagram.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"classDiagram"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ClassDiagram instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ClassDiagram element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassDiagram instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					RapidEntitySerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							RapidEntitySerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassDiagram instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			ClassDiagram instanceOfClassDiagram = element as ClassDiagram;
			global::System.Diagnostics.Debug.Assert(instanceOfClassDiagram != null, "Expecting an instance of ClassDiagram");
	
			// EncryptedConnection
			if (!serializationContext.Result.Failed)
			{
				string attribEncryptedConnection = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "encryptedConnection");
				if (attribEncryptedConnection != null)
				{
					global::System.String valueOfEncryptedConnection;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribEncryptedConnection, out valueOfEncryptedConnection))
					{
						instanceOfClassDiagram.EncryptedConnection = valueOfEncryptedConnection;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "encryptedConnection", typeof(global::System.String), attribEncryptedConnection);
					}
				}
			}
			// ConnectionString
			if (!serializationContext.Result.Failed)
			{
				string attribConnectionString = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "connectionString");
				if (attribConnectionString != null)
				{
					global::System.String valueOfConnectionString;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribConnectionString, out valueOfConnectionString))
					{
						instanceOfClassDiagram.ConnectionString = valueOfConnectionString;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "connectionString", typeof(global::System.String), attribConnectionString);
					}
				}
			}
			// NameSingularization
			if (!serializationContext.Result.Failed)
			{
				string attribNameSingularization = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "nameSingularization");
				if (attribNameSingularization != null)
				{
					global::System.Boolean valueOfNameSingularization;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribNameSingularization, out valueOfNameSingularization))
					{
						instanceOfClassDiagram.NameSingularization = valueOfNameSingularization;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "nameSingularization", typeof(global::System.Boolean), attribNameSingularization);
					}
				}
			}
			// ProviderGuid
			if (!serializationContext.Result.Failed)
			{
				string attribProviderGuid = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "providerGuid");
				if (attribProviderGuid != null)
				{
					global::System.Guid valueOfProviderGuid;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Guid>(serializationContext, attribProviderGuid, out valueOfProviderGuid))
					{
						instanceOfClassDiagram.ProviderGuid = valueOfProviderGuid;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "providerGuid", typeof(global::System.Guid), attribProviderGuid);
					}
				}
			}
			// RemovableTablePrefixes
			if (!serializationContext.Result.Failed)
			{
				string attribRemovableTablePrefixes = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "removableTablePrefixes");
				if (attribRemovableTablePrefixes != null)
				{
					global::System.String valueOfRemovableTablePrefixes;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribRemovableTablePrefixes, out valueOfRemovableTablePrefixes))
					{
						instanceOfClassDiagram.RemovableTablePrefixes = valueOfRemovableTablePrefixes;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "removableTablePrefixes", typeof(global::System.String), attribRemovableTablePrefixes);
					}
				}
			}
			// HasGrid
			if (!serializationContext.Result.Failed)
			{
				string attribHasGrid = RapidEntitySerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "hasGrid");
				if (attribHasGrid != null)
				{
					global::System.Boolean valueOfHasGrid;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribHasGrid, out valueOfHasGrid))
					{
						instanceOfClassDiagram.HasGrid = valueOfHasGrid;
					}
					else
					{	// Invalid property value, ignored.
						RapidEntitySerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "hasGrid", typeof(global::System.Boolean), attribHasGrid);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ClassDiagram based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ClassDiagram, a new ClassDiagram instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ClassDiagram instance, or null if the reader is not pointing to a serialized ClassDiagram instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClassDiagram" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ClassDiagram".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ClassDiagramSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassDiagramSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ClassDiagram based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ClassDiagram.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ClassDiagram instance should be created.</param>	
		/// <returns>Created ClassDiagram instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new ClassDiagram(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ClassDiagram, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ClassDiagram.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassDiagram.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ClassDiagram itself) instance of ClassDiagram based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClassDiagram" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ClassDiagram".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ClassDiagramSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassDiagramSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ClassDiagram based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassDiagram, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassDiagram.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassDiagram.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ClassDiagram instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassDiagram instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ClassDiagram instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ClassDiagram instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ClassDiagram cannot be monikerized.
			RapidEntitySerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ClassDiagram");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ClassDiagram instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassDiagram instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				RapidEntitySerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassDiagram instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			ClassDiagram instanceOfClassDiagram = element as ClassDiagram;
			global::System.Diagnostics.Debug.Assert(instanceOfClassDiagram != null, "Expecting an instance of ClassDiagram");
	
			// EncryptedConnection
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfClassDiagram.EncryptedConnection;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "encryptedConnection", propValue);
	
				}
			}
			// ConnectionString
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfClassDiagram.ConnectionString;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "connectionString", propValue);
	
				}
			}
			// NameSingularization
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfClassDiagram.NameSingularization;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "nameSingularization", serializedPropValue);
				}
			}
			// ProviderGuid
			if (!serializationContext.Result.Failed)
			{
				global::System.Guid propValue = instanceOfClassDiagram.ProviderGuid;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Guid>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "providerGuid", serializedPropValue);
				}
			}
			// RemovableTablePrefixes
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfClassDiagram.RemovableTablePrefixes;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "removableTablePrefixes", propValue);
	
				}
			}
			// HasGrid
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfClassDiagram.HasGrid;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					RapidEntitySerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "hasGrid", serializedPropValue);
				}
			}
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ClassDiagram instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassDiagram instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ClassDiagram instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClassDiagram instance = element as ClassDiagram;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClassDiagram!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassDiagram instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClassDiagram instance = element as ClassDiagram;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClassDiagram!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// A DomainXmlSerializationBehavior implementation for defined behavior RapidEntitySerializationBehavior.
	/// This is the abstract base of the double-derived implementation.
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
	public abstract class RapidEntitySerializationBehaviorBase : DslModeling::DomainXmlSerializationBehavior
	{
		///<summary>
		/// The xml namespace used by this domain model when serializing
		///</summary>
		public const string DomainModelXmlNamespace = @"http://schemas.microsoft.com/dsltools/RapidEntity";
	
		#region Member Variables
		/// <summary>
		/// A list of DomainClass Ids mapped to DomainClassXmlSerializer types.
		/// </summary>
		private static global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerDirectoryEntry> serializerTypes;
	
		/// <summary>
		/// A list of xml namespaces mapped to domain model types.
		/// </summary>
		private static global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerNamespaceEntry> namespaceEntries;
	
		#endregion
	
		#region Constructor
		/// <summary>
		/// Protected constructor to prevent public instantiation.
		/// </summary>
		protected RapidEntitySerializationBehaviorBase() : base() { }
		#endregion
		
		#region Protected Methods
		/// <summary>
		/// Allows custom serializers to be added.
		/// Base implementation doesn't do anything.
		/// </summary>
		/// <returns>Custom serializer types, null or empty list if there's no custom serializer types.</returns>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
		protected virtual global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> CustomSerializerTypes
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return null; }
		}
		#endregion
	
		#region Public Methods
		/// <summary>
		/// This provides a mapping from DomainClass Id to DomainXmlSerializer implementation types.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		public override global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> AllSerializers
		{
			get
			{
				if (RapidEntitySerializationBehavior.serializerTypes == null)
				{
					global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> customSerializerTypes = this.CustomSerializerTypes;
					int customSerializerCount = (customSerializerTypes == null ? 0 : customSerializerTypes.Count);
					RapidEntitySerializationBehavior.serializerTypes = new global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerDirectoryEntry>(28 + customSerializerCount);
	
					#region Serializers defined in this model
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(NamedElement.DomainClassId, typeof(NamedElementSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelRoot.DomainClassId, typeof(ModelRootSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelClass.DomainClassId, typeof(ModelClassSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Field.DomainClassId, typeof(FieldSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Comment.DomainClassId, typeof(CommentSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelType.DomainClassId, typeof(ModelTypeSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ClassModelElement.DomainClassId, typeof(ClassModelElementSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(PersistentKey.DomainClassId, typeof(PersistentKeySerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelAttribute.DomainClassId, typeof(ModelAttributeSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(BaseRelationship.DomainClassId, typeof(BaseRelationshipSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ClassHasFields.DomainClassId, typeof(ClassHasFieldsSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelRootHasComments.DomainClassId, typeof(ModelRootHasCommentsSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Generalization.DomainClassId, typeof(GeneralizationSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(OneToOne.DomainClassId, typeof(OneToOneSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(OneToMany.DomainClassId, typeof(OneToManySerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelRootHasTypes.DomainClassId, typeof(ModelRootHasTypesSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(CommentReferencesSubjects.DomainClassId, typeof(CommentReferencesSubjectsSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ManyToMany.DomainClassId, typeof(ManyToManySerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ClassHasPersistentKeys.DomainClassId, typeof(ClassHasPersistentKeysSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ClassShape.DomainClassId, typeof(ClassShapeSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(CommentBoxShape.DomainClassId, typeof(CommentBoxShapeSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(RelationshipConnector.DomainClassId, typeof(RelationshipConnectorSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(BidirectionalConnector.DomainClassId, typeof(BidirectionalConnectorSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(AggregationConnector.DomainClassId, typeof(AggregationConnectorSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(GeneralizationConnector.DomainClassId, typeof(GeneralizationConnectorSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(CommentConnector.DomainClassId, typeof(CommentConnectorSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ManyToManyConnector.DomainClassId, typeof(ManyToManyConnectorSerializer)));
					RapidEntitySerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ClassDiagram.DomainClassId, typeof(ClassDiagramSerializer)));
					#endregion
					
					// Custom ones
					if (customSerializerCount > 0)
					{
						RapidEntitySerializationBehavior.serializerTypes.AddRange(customSerializerTypes);
					}
				}
				return RapidEntitySerializationBehavior.serializerTypes.AsReadOnly();
			}
		}
		
		/// <summary>
		/// This provides a mapping from xml namespaces to domain model implementation types.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		//[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		public override global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerNamespaceEntry> AllNamespaces
		{
			get
			{
				if (RapidEntitySerializationBehavior.namespaceEntries == null)
				{
					RapidEntitySerializationBehavior.namespaceEntries = new global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerNamespaceEntry>();
					RapidEntitySerializationBehavior.namespaceEntries.Add(new DslModeling::DomainXmlSerializerNamespaceEntry(DomainModelXmlNamespace, typeof(global::consist.RapidEntity.RapidEntityDomainModel)));
				}
				return RapidEntitySerializationBehavior.namespaceEntries.AsReadOnly();
			}
		}
		
		#endregion
	}
	
	/// <summary>
	/// A DomainXmlSerializationBehavior implementation for defined behavior RapidEntitySerializationBehavior.
	/// This is the concrete type of the double-derived implementation.
	/// </summary>
	public sealed partial class RapidEntitySerializationBehavior : RapidEntitySerializationBehaviorBase
	{
		#region Singleton Instance
		/// <summary>
		/// Singleton instance.
		/// </summary>
		private static RapidEntitySerializationBehavior instance;
	
		/// <summary>
		/// Singleton instance.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		public static RapidEntitySerializationBehavior Instance
		{
			get
			{	// No need for synchronization. Most likely running in single-thread environment, and creating an extra instance
				// doesn't really hurt.
				if (RapidEntitySerializationBehavior.instance == null)
					RapidEntitySerializationBehavior.instance = new RapidEntitySerializationBehavior ();
				return RapidEntitySerializationBehavior.instance;
			}
		}
	
		/// <summary>
		/// Private constructor to prevent public instantiation.
		/// </summary>
		private RapidEntitySerializationBehavior() : base() { }
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Moniker resolver for serialization behavior RapidEntitySerializationBehavior.
	/// </summary>
	public partial class RapidEntitySerializationBehaviorMonikerResolver : RapidEntitySerializationBehaviorMonikerResolverBase
	{
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="store">Store for this moniker resolver.</param>
		/// <param name="directory">Directory to used by this resolver to look up for serializers.</param>
		public RapidEntitySerializationBehaviorMonikerResolver(DslModeling::Store store, DslModeling::DomainXmlSerializerDirectory directory)
			: base(store,directory)
		{
		}
	}
	
	/// <summary>
	/// Base moniker resolver for serialization behavior RapidEntitySerializationBehavior.
	/// </summary>
	public partial class RapidEntitySerializationBehaviorMonikerResolverBase : DslModeling::SimpleMonikerResolver
	{
		#region Member Variables
		/// <summary>
		/// Look-up directory to find serializers for domain classes.
		/// </summary>
		private DslModeling::DomainXmlSerializerDirectory directory;
		#endregion
	
		#region Constructor
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="store">Store for this moniker resolver.</param>
		/// <param name="directory">Directory to used by this resolver to look up for serializers.</param>
		public RapidEntitySerializationBehaviorMonikerResolverBase(DslModeling::Store store, DslModeling::DomainXmlSerializerDirectory directory)
			: base (store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException("directory");
			#endregion
	
			this.directory = directory;
		}
		#endregion
	
		#region Base Overrides
		/// <summary>
		/// Tells if a DomainClass can be monikerized or not.
		/// </summary>
		/// <param name="domainClassInfo">DomainClassInfo of the DomainClass to be checked.</param>
		/// <returns>True if the DomainClass can be monikerized, false otherwise.</returns>
		protected override bool CanBeMonikerized(DslModeling::DomainClassInfo domainClassInfo)
		{
			if (this.IsDisposed || this.directory == null || domainClassInfo == null)
				return false;
				
			DslModeling::DomainClassXmlSerializer serializer = this.directory.GetSerializer(domainClassInfo.Id);
			if (serializer != null)
				return (!string.IsNullOrEmpty(serializer.MonikerTagName));
			return false;
		}
			
		/// <summary>
		/// Calculate the fully qualified monikerized string of the given ModelElement.
		/// </summary>
		/// <param name="mel">ModelElement to get moniker from.</param>
		/// <returns>Calculated moniker string, returns null or empty string is the given ModelElement cannot be monikerized.</returns>
		protected override string CalculateQualifiedName(DslModeling::ModelElement mel)
		{
			if (this.IsDisposed || this.directory == null || mel == null)
				return string.Empty;
	
			string result = string.Empty;
			DslModeling::DomainClassXmlSerializer serializer = this.directory.GetSerializer(mel.GetDomainClass().Id);
			if (serializer != null)
				result = serializer.CalculateQualifiedName(this.directory, mel);
			return result;
		}
		
		/// <summary>
		/// Called at the end of synchronization when they're unresolved monikers.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to store error/warning messages.</param>
		/// <param name="moniker">Unresolved moniker.</param>
		protected override void OnUnresolvedMoniker(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			if (serializationResult != null)
			{
				RapidEntitySerializationBehaviorSerializationMessages.UnresolvedMoniker(serializationResult, moniker);
			}
		}
		
		/// <summary>
		/// Called when resolving a moniker causes a duplicate link to be created.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to store error/warning messages.</param>
		/// <param name="moniker">Moniker that causes duplicate link to be created.</param>
		protected override void OnMonikerResolvedToDuplicateLink(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			if (serializationResult != null)
			{
				RapidEntitySerializationBehaviorSerializationMessages.MonikerResolvedToDuplicateLink(serializationResult, moniker);
			}
			base.OnMonikerResolvedToDuplicateLink(serializationResult, moniker);
		}
		
		/// <summary>
		/// Called when two new elements are giving the same moniker, which will cause ambiguity during moniker resolution.
		/// </summary>
		/// <param name="context">SerializationContext to store error/warning messages.</param>
		/// <param name="moniker">Moniker that both elements give.</param>
		/// <param name="element1">The first element giving the moniker.</param>
		/// <param name="element2">The second element giving the same moniker.</param>
		protected override void OnAmbiguousMoniker(DslModeling::SerializationContext context, string moniker, DslModeling::ModelElement element1, DslModeling::ModelElement element2)
		{
			if (context != null)
			{
				RapidEntitySerializationBehaviorSerializationMessages.AmbiguousMoniker(context, moniker, element1, element2);
			}
			base.OnAmbiguousMoniker(context, moniker, element1, element2);
		}
		
		/// <summary>
		/// Error message for UnresolvedMonikerException.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
		protected override string UnresolvedMonikerExceptionMessage
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return RapidEntitySerializationBehaviorSerializationMessages.ResourceManager.GetString("CannotOpenDocument"); }
		}
		#endregion
	}
}

namespace consist.RapidEntity
{
	/// <summary>
	/// Utility class to provide serialization messages
	/// </summary>
	public static partial class RapidEntitySerializationBehaviorSerializationMessages
	{
		/// <summary>
		/// ResourceManager to get serialization messages from.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)] // Will trigger creation otherwise.
		public static global::System.Resources.ResourceManager ResourceManager
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return RapidEntityDomainModel.SingletonResourceManager; }
		}
	
		#region Warnings
		/// <summary>
		/// Add a warning for ambiguous schemas.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="targetNamespace">Target namespace to be resolved.</param>
		/// <param name="schemaPath">The schema that is used to resolve the definition of the target namespace.</param>
		public static void AmbiguousSchema(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string targetNamespace, string schemaPath)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(targetNamespace));
			if (string.IsNullOrEmpty(targetNamespace))
				throw new global::System.ArgumentNullException("targetNamespace");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(schemaPath));
			if (string.IsNullOrEmpty(schemaPath))
				throw new global::System.ArgumentNullException("schemaPath");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("AmbiguousSchema"),
					targetNamespace,
					schemaPath
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning when a full-form relationship seems to be serialized in short-form.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type of the relationship.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the relationship, making it MemberInfo only adds confusion.")]
		public static void ExpectingFullFormRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Type relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(relationshipType != null);
			if (relationshipType == null)
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("ExpectingFullFormRelationship"),
					reader.Name,
					relationshipType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning when a short-form relationship seems to be serialized in full-form.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type of the relationship.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the relationship, making it MemberInfo only adds confusion.")]
		public static void ExpectingShortFormRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Type relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(relationshipType != null);
			if (relationshipType == null)
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("ExpectingShortFormRelationship"),
					relationshipType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for invalid property value with the given type, which will be ignored.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="propertyName">Name of the property.</param>
		/// <param name="propertyType">Type of the property.</param>
		/// <param name="value">Invalid value that causes this warning.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the property, making it MemberInfo only adds confusion.")]
		public static void IgnoredPropertyValue(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string propertyName, global::System.Type propertyType, string value)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(propertyType != null);
			if (propertyType == null)
				throw new global::System.ArgumentNullException("propertyType");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(propertyName));
			if (string.IsNullOrEmpty(propertyName))
				throw new global::System.ArgumentNullException("propertyName");
			#endregion
			
			if (value == null)
				value = "<null>";
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("IgnoredPropertyValue"),
					value,
					propertyName,
					propertyType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for missing "Id" property.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="newId">Auto-generated new Id.</param>
		public static void MissingId(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Guid newId)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MissingId"),
					newId.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture)
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
			
		/// <summary>
		/// Add an warning for moniker resolved to duplicate link. The moniker will be ignored.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to add the error message to.</param>
		/// <param name="moniker">Offending moniker.</param>
		public static void MonikerResolvedToDuplicateLink(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationResult != null);
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationResult,
				moniker.Location,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MonikerResolvedToDuplicateLink"),
					moniker.MonikerName
				),
				moniker.Line,
				moniker.Column
			);
		}
		
		/// <summary>
		/// Add a warning for no schema found for the given target namespace, schema validation will be skipped in this case.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="targetNamespace">Target namespace that cannot be resolved.</param>
		public static void NoSchema(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string targetNamespace)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(targetNamespace));
			if (string.IsNullOrEmpty(targetNamespace))
				throw new global::System.ArgumentNullException("targetNamespace");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("NoSchema"),
					targetNamespace
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for schema validation error.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="message">Validation message reported from schema validation.</param>
		public static void SchemaValidationError(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string message)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(message));
			if (string.IsNullOrEmpty(message))
				throw new global::System.ArgumentNullException("message");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				message,
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an warning for unexpected XML element.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		public static void UnexpectedXmlElement(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			#endregion
				
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("UnexpectedXmlElement"),
					reader.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		#endregion
	
		#region Errors
		/// <summary>
		/// Add an error for ambiguous moniker.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="moniker">The ambiguous moniker string.</param>
		/// <param name="element1">The first element using the given moniker.</param>
		/// <param name="element2">The second element using the given moniker.</param>
		public static void AmbiguousMoniker(DslModeling::SerializationContext serializationContext, string moniker, DslModeling::ModelElement element1, DslModeling::ModelElement element2)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			global::System.Diagnostics.Debug.Assert(element1 != null);
			if (element1 == null)
				throw new global::System.ArgumentNullException("element1");
			global::System.Diagnostics.Debug.Assert(element2 != null);
			if (element2 == null)
				throw new global::System.ArgumentNullException("element2");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("AmbiguousMoniker"),
					moniker,
					DslModeling::SerializationUtilities.GetElementName(element1),
					DslModeling::SerializationUtilities.GetElementName(element2)
				),
				null	// No location info available
			);
		}
		
		/// <summary>
		/// Add an error for not able to monikerize an instance of the given DomainClass.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="domainClassName">Name of the DomainClass whose instance cannot be monikerized.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Justification = "Generated code.")]	
		public static void CannotMonikerizeElement(DslModeling::SerializationContext serializationContext, string domainClassName)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(domainClassName));
			if (string.IsNullOrEmpty(domainClassName))
				throw new global::System.ArgumentNullException("domainClassName");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext.Result,
				null,	/* no location available for this error, because save failed. */
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("CannotMonikerizeElement"),
					domainClassName
				),
				0,
				0
			);
		}
		
		/// <summary>
		/// Add an error for dangling relationship instance.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type name of the relationship.</param>
		public static void DanglingRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(relationshipType));
			if (string.IsNullOrEmpty(relationshipType))
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("DanglingRelationship"),
					relationshipType
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for invalid property value with given type.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="propertyName">Name of the property.</param>
		/// <param name="propertyType">Type of the property.</param>
		/// <param name="value">Invalid value that causes this error.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the property, making it MemberInfo only adds confusion.")]
		public static void InvalidPropertyValue(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string propertyName, global::System.Type propertyType, string value)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(propertyType != null);
			if (propertyType == null)
				throw new global::System.ArgumentNullException("propertyType");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(propertyName));
			if (string.IsNullOrEmpty(propertyName))
				throw new global::System.ArgumentNullException("propertyName");
			#endregion
			
			if (value == null)
				value = "<null>";
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("InvalidPropertyValue"),
					value,
					propertyName,
					propertyType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for missing moniker.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="monikerAttributeName">Name of the attribute that should hold the moniker.</param>
		public static void MissingMoniker(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string monikerAttributeName)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerAttributeName));
			if (string.IsNullOrEmpty(monikerAttributeName))
				throw new global::System.ArgumentNullException("monikerAttributeName");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MissingMoniker"),
					monikerAttributeName
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for unresolved moniker.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to add the error message to.</param>
		/// <param name="moniker">Unresolved moniker.</param>
		public static void UnresolvedMoniker(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationResult != null);
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationResult,
				moniker.Location,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("UnresolvedMoniker"),
					moniker.MonikerName
				),
				moniker.Line,
				moniker.Column
			);
		}
	
		/// <summary>
		/// Add an error for Version mismatch.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="expectedVersion">The version that's expected.</param>
		/// <param name="actualVersion">Actual version from the file.</param>
		public static void VersionMismatch(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Version expectedVersion, global::System.Version actualVersion)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(expectedVersion != null);
			if (expectedVersion == null)
				throw new global::System.ArgumentNullException("expectedVersion");
			global::System.Diagnostics.Debug.Assert(actualVersion != null);
			if (actualVersion == null)
				throw new global::System.ArgumentNullException("actualVersion");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("VersionMismatch"), 
					actualVersion.ToString(4), 
					expectedVersion.ToString(4)
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		#endregion
	}
}
namespace consist.RapidEntity
{
	/// <summary>
	/// Provides an implementation of the IDomainModelSerializer interface
	/// that can be used to serialize / deserialize the RapidEntity domain model.
	/// </summary>
	/// <remarks>Double-derived class - the default implementation is in RapidEntityDomainModelSerializerBase.
	/// This class exist so users can customize behavior easily.</remarks>
	[global::System.ComponentModel.Composition.Export(typeof(DslModeling::IDomainModelSerializer))]
	[DslModeling::DomainModelSerializer(typeof(global::consist.RapidEntity.RapidEntityDomainModel), global::consist.RapidEntity.RapidEntitySerializationBehavior.DomainModelXmlNamespace, "rapd")]
	public partial class RapidEntityDomainModelSerializer : RapidEntityDomainModelSerializerBase
	{
	}
	
	
	/// <summary>
	/// Base class that implements IDomainModelSerializer
	/// </summary>
	public abstract partial class RapidEntityDomainModelSerializerBase : DslModeling::IDomainModelSerializer
	{
	
		#region Public properties
	
		/// <summary>
		/// The XML namespace used when serializing the domain model
		/// </summary>
		public virtual string DomainModelNamespace
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return global::consist.RapidEntity.RapidEntitySerializationBehavior.DomainModelXmlNamespace; }
		}
	
		/// <summary>
		/// Returns true: this DSL can be serialized / deserialized directly.
		/// </summary>
		public virtual bool IsSerializable
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return true; }
		}
	
		/// <summary>
		/// The type of the domain model
		/// </summary>
		public virtual global::System.Type DomainModelType
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return typeof(global::consist.RapidEntity.RapidEntityDomainModel); }
		}
	
		/// <summary>
		/// File extension used for model files of this kind of domain model
		/// </summary>
		/// <remarks>If a domain model type cannot be serialized independently, or cannot
		/// be serialized to a file, it should return null or empty.</remarks>
		public string ModelFileExtension
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return "rapd"; }
		}
	
		#endregion
		
		
		#region Load / Save model methods
		
		/// <summary>
		/// Loads a ModelRoot instance and its associated diagram file.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the load operation.</param>
		/// <param name="partition">Partition in which the new ModelRoot instance will be created.</param>
		/// <param name="fileName">Name of the file from which the ModelRoot instance will be deserialized.</param>
		/// <param name="serializerLocator">Used to locate any additional domain model types required to load the model. Can be null.</param>
		/// <returns>The loaded ModelRoot instance.</returns>
		public virtual DslModeling::ModelElement LoadModel(DslModeling::SerializationResult serializationResult, 
			DslModeling::Partition partition, 
			string fileName, 
			DslModeling::ISerializerLocator serializerLocator)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (partition == null) { throw new global::System.ArgumentNullException("partition"); }
			if (string.IsNullOrEmpty(fileName)) { throw new global::System.ArgumentNullException("fileName"); }
	
			return RapidEntitySerializationHelper.Instance.LoadModel(serializationResult, partition, fileName, null, null, serializerLocator);
		}
	
		/// <summary>
		/// Saves the given model root to the given file, with specified encoding.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="modelRoot">ModelRoot instance to be saved.</param>
		/// <param name="fileName">Name of the file in which the ModelRoot instance will be saved.</param>
		/// <param name="encoding">Encoding to use when saving the ModelRoot instance.</param>
		public void SaveModel(DslModeling::SerializationResult serializationResult, 
			DslModeling::ModelElement modelRoot, 
			string fileName, 
			System.Text.Encoding encoding)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (modelRoot == null) { throw new global::System.ArgumentNullException("modelRoot"); }
			if (string.IsNullOrEmpty("fileName")) { throw new global::System.ArgumentNullException("fileName"); }
	
			global::consist.RapidEntity.ModelRoot rootElement = modelRoot as global::consist.RapidEntity.ModelRoot;
			if (rootElement == null)
			{
				string errorMessage = string.Format(global::System.Globalization.CultureInfo.CurrentCulture,
					global::consist.RapidEntity.RapidEntityDomainModel.SingletonResourceManager.GetString("InvalidSaveRootElementType"),
					modelRoot.GetType().ToString());
	
				throw new global::System.ArgumentException(errorMessage, "modelRoot");
	
			}
	
			RapidEntitySerializationHelper.Instance.SaveModel(serializationResult, rootElement, fileName,encoding, true);
		}
	
		#endregion
	
		#region Load / Save model and diagram methods
	
		/// <summary>
		/// Calculates and returns the name of the diagram file for the specified model file
		/// </summary>
		/// <param name="modelFileName">The relevant model file name</param>
		/// <returns>Name of the associated diagram file</returns>
		/// <remarks>There is no guarantee that either the model file or the calculated diagram file exist.</remarks>
		public virtual string CalculateDiagramFileName(string modelFileName)
		{
			if (string.IsNullOrEmpty(modelFileName))
			{
				throw new global::System.ArgumentNullException("modelFileName");
			}
			return modelFileName + ".diagram";
		}
	
		/// <summary>
		/// Loads a ModelRoot instance and its associated diagram file.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the load operation.</param>
		/// <param name="modelPartition">Partition in which the new ModelRoot instance will be created.</param>
		/// <param name="modelFileName">Name of the file from which the ModelRoot instance will be deserialized.</param>
		/// <param name="diagramPartition">Partition in which the new ClassDiagram instance will be created.</param>
		/// <param name="diagramFileName">Name of the file from which the ClassDiagram instance will be deserialized.</param>
		/// <param name="serializerLocator">Used to locate any additional domain model types required to load the model. Can be null.</param>
		/// <returns>The loaded ModelRoot instance.</returns>
		public DslModeling::ModelElement LoadModelAndDiagram(DslModeling::SerializationResult serializationResult, 
			DslModeling::Partition modelPartition, 
			string modelFileName, 
			DslModeling::Partition diagramPartition, 
			string diagramFileName, 
			DslModeling::ISerializerLocator serializerLocator)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (modelPartition == null) { throw new global::System.ArgumentNullException("modelPartition"); }
			if (string.IsNullOrEmpty(modelFileName)) { throw new global::System.ArgumentNullException("modelFileName"); }
			if (diagramPartition == null) { throw new global::System.ArgumentNullException("diagramPartition"); }
			if (string.IsNullOrEmpty(diagramFileName)) { throw new global::System.ArgumentNullException("diagramFileName"); }
	
			return RapidEntitySerializationHelper.Instance.LoadModelAndDiagram(serializationResult, modelPartition, modelFileName, diagramPartition, diagramFileName, null, null, serializerLocator);
		}
	
		/// <summary>
		/// Saves the given ModelRoot and ClassDiagram to the given files, with specified encoding.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="modelRoot">ModelRoot instance to be saved.</param>
		/// <param name="modelFileName">Name of the file in which the CanonicalSampleRoot instance will be saved.</param>
		/// <param name="diagram">ClassDiagram to be saved.</param>
		/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
		/// <param name="encoding">Encoding to use when saving the diagram.</param>
		public void SaveModelAndDiagram(DslModeling::SerializationResult serializationResult, 
			DslModeling::ModelElement modelRoot, 
			string modelFileName, 
			DslModeling::ModelElement diagram, 
			string diagramFileName, 
			System.Text.Encoding encoding)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (modelRoot == null) { throw new global::System.ArgumentNullException("modelRoot"); }
			if (string.IsNullOrEmpty("modelFileName")) { throw new global::System.ArgumentNullException("modelFileName"); }
			if (diagram == null) { throw new global::System.ArgumentNullException("diagram"); }
			if (string.IsNullOrEmpty("diagramFileName")) { throw new global::System.ArgumentNullException("diagramFileName"); }
	
			global::consist.RapidEntity.ModelRoot typedRoot = modelRoot as global::consist.RapidEntity.ModelRoot;
			if (typedRoot == null)
			{
				string errorMessage = string.Format(global::System.Globalization.CultureInfo.CurrentCulture,
					global::consist.RapidEntity.RapidEntityDomainModel.SingletonResourceManager.GetString("InvalidSaveRootElementType"),
					modelRoot.GetType().ToString());
	
				throw new global::System.ArgumentException(errorMessage, "modelRoot");
			}
			global::consist.RapidEntity.ClassDiagram typedDiagram = diagram as global::consist.RapidEntity.ClassDiagram;
			if (typedDiagram == null)
			{
				string errorMessage = string.Format(global::System.Globalization.CultureInfo.CurrentCulture,
					global::consist.RapidEntity.RapidEntityDomainModel.SingletonResourceManager.GetString("InvalidSaveDiagramType"),
					diagram.GetType().ToString());
	
				throw new global::System.ArgumentException(errorMessage, "diagram");
			}
	
			RapidEntitySerializationHelper.Instance.SaveModelAndDiagram(serializationResult, typedRoot, modelFileName, typedDiagram, diagramFileName, encoding, true);
		}
	
		#endregion
		
	}
}


